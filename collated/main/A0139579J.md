# A0139579J
###### \java\seedu\inbx0\commons\events\ui\ShowReminderRequestEvent.java
``` java
public class ShowReminderRequestEvent extends BaseEvent {
    
    public final ReadOnlyTask task;

    public ShowReminderRequestEvent(ReadOnlyTask task) {
        this.task = task;
    }
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\inbx0\logic\commands\AddCommand.java
``` java
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the tasklist. \n"
            + "1. Event Task \n"
            + "Parameters: NAME s=STARTDATE st=STARTTIME e=ENDDATE et=ENDTIME [i=IMPORTANCE] [t=TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " homework s=tomorrow st=9a e=next week et=9a i=r t=CS2103 t=project \n \n"
            + "2. Floating Task \n"
            + "Parameters: NAME [i=IMPORTANCE] [t=TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " read shakespeare i=r t=Hamlet t=Romeo \n \n"
            + "3. Deadline Task \n"
            + "Parameters: NAME e=ENDDATE et=ENDTIME [i=IMPORTANCE] [t=TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " complete project e=next month et=10a i=r t=Hamlet t=Romeo \n";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the tasklist";

    private final Task toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String startDate, String startTime, String endDate, String endTime, String level, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(startDate),
                new Time(startTime),
                new Date(endDate),
                new Time(endTime),
                new Importance(level),
                new UniqueTagList(tagSet),
                new UniqueReminderList()
        );
    }
    
    
    public AddCommand(String name, String startDate, String startTime, String endDate, String endTime, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(startDate),
                new Time(startTime),
                new Date(endDate),
                new Time(endTime),
                new Importance(""),
                new UniqueTagList(tagSet),
                new UniqueReminderList()
        );
    }

    public AddCommand(String name, Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(""),
                new Time(""),
                new Date(""),
                new Time(""),
                new Importance(""),
                new UniqueTagList(tagSet),
                new UniqueReminderList()
        );
    }
    
    public AddCommand(String name, String level, Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(""),
                new Time(""),
                new Date(""),
                new Time(""),
                new Importance(level),
                new UniqueTagList(tagSet),
                new UniqueReminderList()
        );
    }
    
    public AddCommand(String name, String endDate, String endTime, String level, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(""),
                new Time(""),
                new Date(endDate),
                new Time(endTime),
                new Importance(level),
                new UniqueTagList(tagSet),
                new UniqueReminderList()
        );
    }
    
    public AddCommand(String name, String endDate, String endTime, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(""),
                new Time(""),
                new Date(endDate),
                new Time(endTime),
                new Importance(""),
                new UniqueTagList(tagSet),
                new UniqueReminderList()
        );
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            indicateShowNormalTaskListEventCommand();
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }
    
```
###### \java\seedu\inbx0\logic\commands\EditCommand.java
``` java
public class EditCommand extends Command {
    
    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) [n=NAME] [s=STARTDATE] [st=STARTTIME] \n"
            + "[e=ENDDATE] [et=ENDTIME] [i=IMPORTANCE] [t=TAG]... (one optional parameter is required)\n"
            + "Example: " + COMMAND_WORD + " 1 s=tomorrow st=9a e=next week et=9a i=r t=CS2103 t=project \n \n"
            + "You can also change an event or a deadline task to a floating task \n"
            + "Parameters: INDEX (must be a positive integer) \n"
            + "Example: " + COMMAND_WORD + " 1 float \n";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the tasklist";
    public static final String MESSAGE_INVALID_ARGUMENTS = "The arguments provided are invalid.";
    public static final int TOTAL_NUMBER_OF_ARGUMENTS = 6;
    
    public final int targetIndex;
    public String [] editArguments;
    public UniqueTagList tags;

    public EditCommand(int targetIndex, String [] argumentsToEdit, Set<String> tags) throws IllegalValueException {
        
        this.targetIndex = targetIndex;
        
        if(tags == null) {
            this.tags = null;
        }
        else {
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : tags) {
                tagSet.add(new Tag(tagName));
            }
            
            UniqueTagList editedTags = null;
            
            if(!tagSet.isEmpty()) {
                editedTags = new UniqueTagList(tagSet);
            }
         
            this.tags = editedTags;
        }
        this.editArguments = argumentsToEdit;    
    }


    private UniqueTagList obtainUniqueTagList(ReadOnlyTask taskToEdit) {
        
      UniqueTagList original = taskToEdit.getTags();
            
      return original;
    }
    
    private UniqueReminderList obtainUniqueReminderList(ReadOnlyTask taskToEdit) {
        
        UniqueReminderList original = taskToEdit.getReminders();
              
        return original;
    }
    
    private Task updateReminders(Task toEditWith) {
        Task newTask = toEditWith;
        UniqueReminderList reminders = toEditWith.getReminders();
        for(ReminderTask r: reminders) {
            r.setReadableOnlyTask(newTask);
        }
        toEditWith.setReminders(reminders);
        Task newUpdatedTask = toEditWith;
        
        return newUpdatedTask;
        
    }


    private String[] obtainArguments(String[] editArguments, ReadOnlyTask taskToEdit) {
       
        String [] originalArguments = new String[6];
                    
        originalArguments[0] = taskToEdit.getName().getName();
        originalArguments[1] = taskToEdit.getStartDate().getDate();
        originalArguments[2] = taskToEdit.getStartTime().getTime();
        originalArguments[3] = taskToEdit.getEndDate().getDate();
        originalArguments[4] = taskToEdit.getEndTime().getTime();
        originalArguments[5] = taskToEdit.getLevel().getLevel();
            
        for(int i = 0; i < TOTAL_NUMBER_OF_ARGUMENTS; i++) {
            if(editArguments[i] == null)
                editArguments[i] = originalArguments[i];                       
        }
        
        return editArguments;
    }

    private Task createToEditWithTask(String[] editArguments, UniqueTagList tags, UniqueReminderList reminders) throws IllegalValueException {
        Task toEditWith = new Task (
                new Name(editArguments[0]),
                new Date(editArguments[1]),
                new Time(editArguments[2]),
                new Date(editArguments[3]),
                new Time(editArguments[4]),
                new Importance(editArguments[5]),
                tags,
                reminders
                );
        return toEditWith;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);
        this.editArguments = obtainArguments(editArguments, taskToEdit);
        
        if(tags == null)
            this.tags = obtainUniqueTagList(taskToEdit);
        
        UniqueReminderList reminders = obtainUniqueReminderList(taskToEdit);
        
        Task toEditWith = null;
        try {
            toEditWith = createToEditWithTask(editArguments, tags, reminders);
        } catch (IllegalValueException e1) {
            return new CommandResult(String.format(MESSAGE_INVALID_ARGUMENTS, MESSAGE_USAGE));
        }
        
        Task updatedReminders = updateReminders(toEditWith);
        
        try {
            model.editTask(taskToEdit, updatedReminders);
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        } catch (UniqueTaskList.DuplicateTaskException e ) {    
            return new CommandResult(MESSAGE_DUPLICATE_TASK);            
        }

        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, toEditWith));
    }


    @Override
    public boolean canUndo() {
        return true;
    }



}
```
###### \java\seedu\inbx0\logic\commands\ListCommand.java
``` java
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS = "Listed all tasks";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": \n 1. Lists all tasks associated with the date and "
            + "displays them as a list with index numbers.\n"
            + "Without any parameters, it will display all tasks.\n"
            + "Parameters: [DATE]\n"
            + "Example: " + COMMAND_WORD + " today\n"
            + "2. Lists all tasks that are due to a certain date \n"
            + "Parameters: due DATE\n"
            + "Example: " + COMMAND_WORD + " due next week\n"
            + "3. Lists all tasks that are overdue \n"
            + "Parameters: overdue\n"
            + "Example: " + COMMAND_WORD + " overdue\n";
    
    private final String checkDate;
    private final String preposition;
    private static final Pattern TASKS_DUE_UNTIL_DATE_LIST_FORMAT = Pattern.compile(" due (?<date>[^$]+)");
    
    public ListCommand() {
        this.checkDate = "";
        this.preposition = "";
    }

    public ListCommand(String arguments) throws IllegalValueException {
        final Matcher matcher = TASKS_DUE_UNTIL_DATE_LIST_FORMAT.matcher(arguments);
        if(matcher.matches()) {
            this.preposition = "due";
            Date checkDate = new Date(matcher.group("date"));
            this.checkDate = checkDate.value;
            
        }
        else if(arguments.trim().equals("overdue")) {
            this.checkDate = "";
            this.preposition = "overdue";
        }
        else {
            Date checkDate = new Date (arguments.trim());
            this.checkDate = checkDate.value;
            this.preposition = "";
        }
    }

    @Override
    public CommandResult execute() {
        if(checkDate.equals("") && preposition.equals("")) {
            model.updateFilteredListToShowAll();
            indicateShowNormalTaskListEventCommand();
            return new CommandResult(MESSAGE_SUCCESS);
        }
        else {
                model.updateFilteredTaskList(checkDate, preposition);
                indicateShowNormalTaskListEventCommand();
                return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        }       
    }

    @Override
    public boolean canUndo() {
        return false;
    }
}
```
###### \java\seedu\inbx0\logic\commands\MarkCompleteCommand.java
``` java
public class MarkCompleteCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing as completed.\n"
            + "Parameters: INDEX (must be a positive integer and can be more than one input given)\n"
            + "Example: " + COMMAND_WORD + " 1 2 3";

    public static final String MESSAGE_TASK_ALREADY_COMPLETED = "One or more tasks are already completed";
    public static final String MESSAGE_INVALID_ARGUMENTS = "The arguments provided are invalid.";

    public final Set<Integer> indexNum;

    public MarkCompleteCommand(Set<Integer> indexNumSet) throws IllegalValueException {
        this.indexNum = validateSet(indexNumSet);
    }


    private Set<Integer> validateSet(Set<Integer> indexNumSet) throws IllegalValueException {
        if(indexNumSet.isEmpty())
            throw new IllegalValueException(MESSAGE_INVALID_ARGUMENTS);
        return indexNumSet;        
        
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        
        for(Integer i : indexNum) {
            if (lastShownList.size() < i) {
                indicateAttemptToExecuteIncorrectCommand();
                return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
        }
        
        for(Integer i : indexNum) {
            ReadOnlyTask toMarkTaskCompleted = lastShownList.get(i - 1);
            Task completedTask = null;
            
            if(toMarkTaskCompleted.getIsCompleted()) {
                return new CommandResult(MESSAGE_TASK_ALREADY_COMPLETED);
            }
            try {
                completedTask = new Task (
                    new Name(toMarkTaskCompleted.getName().getName()),
                    new Date(toMarkTaskCompleted.getStartDate().getDate()),
                    new Time(toMarkTaskCompleted.getStartTime().getTime()),
                    new Date(toMarkTaskCompleted.getEndDate().getDate()),
                    new Time(toMarkTaskCompleted.getEndTime().getTime()),
                    new Importance(toMarkTaskCompleted.getLevel().getLevel()),
                    toMarkTaskCompleted.getTags(),
                    toMarkTaskCompleted.getReminders()
                    );
            } catch (IllegalValueException e) {
                return new CommandResult(String.format(MESSAGE_INVALID_ARGUMENTS, MESSAGE_USAGE));
            }
            
            completedTask.setCompleted(true);
            
            try {
                model.markTaskComplete(toMarkTaskCompleted, completedTask);
            } catch (TaskNotFoundException tnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        return new CommandResult(getMessageForTasksCompletedSummary(indexNum.size()));       
    }


    @Override
    public boolean canUndo() {
        return true;
    }

}
```
###### \java\seedu\inbx0\logic\commands\RemindCommand.java
``` java
public class RemindCommand extends Command {

    public static final String COMMAND_WORD = "rem";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Adds a reminder for the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX s=[START DATE] [START TIME] ( Index must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 s=5 minutes from now";

    public static final String MESSAGE_REMINDER_TASK_SUCCESS = "Added Reminder for Task: %1$s";
    public static final String MESSAGE_REMINDER_CONSTRAINTS = "The reminder date or time is invalid.";
    public static final int TOTAL_NUMBER_OF_ARGUMENTS = 6;
    
    public final int targetIndex;
    public final Date startDate;
    public final Time startTime;

    public RemindCommand(int targetIndex, String date) {
        this.targetIndex = targetIndex;
        
        Date startDate = null;
        Time startTime = null;
        try {
            startDate = new Date(date);
            startTime = new Time(date);
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        
        this.startDate = startDate;
        this.startTime = startTime;
    }
    
    private boolean isValidDateAndTime(Date date, Time time) {
        boolean isValidDate = false;
        boolean isValidTime = false;
        
        Date currentDate = null;
        try {
          currentDate = new Date("now");
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        
        SimpleDateFormat ft = new SimpleDateFormat ("HHmm");
        List<java.util.Date> current = new Parser().parse("now").get(0).getDates();
        int currentTime = Integer.parseInt(ft.format(current.get(0)));
        
        int currentHour = currentTime / 100;
        int currentMin = currentTime % 100;
        
        if(startTime == null) {
            return false;
        }
        if(("").equals(startTime.value)) {
            isValidTime = true;
        } else {
            
            int reminderTime = Integer.parseInt(startTime.getTime().replaceAll("\\D+",""));
            int reminderHour = reminderTime / 100;
            int reminderMin = reminderTime % 100;
            
            if((reminderHour > currentHour) |
               (reminderHour == currentHour && reminderMin > currentMin))
                isValidTime = true;         
        }
        
        int currentDay = currentDate.getDay();
        int currentMonth = currentDate.getMonth();
        int currentYear = currentDate.getYear();
        
        int reminderDay = startDate.getDay();
        int reminderMonth = startDate.getMonth();
        int reminderYear = startDate.getYear();
        
        if((reminderYear > currentYear) |
           (reminderYear == currentYear && reminderMonth > currentMonth) |
           (reminderYear == currentYear && reminderMonth == currentMonth && reminderDay >= currentDay))
            isValidDate = true;
        
        if(isValidDate && isValidTime) {
            return true;
        } else {
            return false;
        }
    }
    private Task createToEditWithTask(String[] editArguments, UniqueTagList tags, UniqueReminderList reminders) throws IllegalValueException {
        Task toEditWith = new Task (
                new Name(editArguments[0]),
                new Date(editArguments[1]),
                new Time(editArguments[2]),
                new Date(editArguments[3]),
                new Time(editArguments[4]),
                new Importance(editArguments[5]),
                tags,
                reminders
                );
        return toEditWith;
    }
    
    private String[] obtainArguments(String[] editArguments, ReadOnlyTask taskToEdit) {
        
        String [] originalArguments = new String[6];
                    
        originalArguments[0] = taskToEdit.getName().getName();
        originalArguments[1] = taskToEdit.getStartDate().getDate();
        originalArguments[2] = taskToEdit.getStartTime().getTime();
        originalArguments[3] = taskToEdit.getEndDate().getDate();
        originalArguments[4] = taskToEdit.getEndTime().getTime();
        originalArguments[5] = taskToEdit.getLevel().getLevel();
            
        for(int i = 0; i < TOTAL_NUMBER_OF_ARGUMENTS; i++) {
            if(editArguments[i] == null)
                editArguments[i] = originalArguments[i];                       
        }
        
        return editArguments;
    }
    
    private UniqueTagList obtainUniqueTagList(ReadOnlyTask taskToEdit) {
        
        UniqueTagList original = taskToEdit.getTags();
              
        return original;
      }
      
      private UniqueReminderList obtainUniqueReminderList(ReadOnlyTask taskToEdit, ReminderTask reminder) {
          UniqueReminderList original = taskToEdit.getReminders();
          try {
            original.add(reminder);
        } catch (DuplicateReminderException e) {

            e.printStackTrace();
        }
          return original;
      }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        
        if(!isValidDateAndTime(startDate, startTime)) {
            return new CommandResult(MESSAGE_REMINDER_CONSTRAINTS);
        }
        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToAddReminder = lastShownList.get(targetIndex - 1);
        
        ReminderTask newReminder = new ReminderTask(startDate, startTime, taskToAddReminder, true);
        String [] editArguments = new String [6];
        editArguments = obtainArguments(editArguments, taskToAddReminder);
        UniqueTagList tags = obtainUniqueTagList(taskToAddReminder);
        UniqueReminderList reminders = obtainUniqueReminderList(taskToAddReminder, newReminder);
        
        Task withReminder = null;
        try {
            withReminder = createToEditWithTask(editArguments, tags, reminders);
            EventsCenter.getInstance().post(new TaskPanelSelectionChangedEvent(withReminder));
        } catch (IllegalValueException e1) {
            return new CommandResult(MESSAGE_USAGE);
        }
        try {
            model.editTask(taskToAddReminder, withReminder);
        } catch (DuplicateTaskException | TaskNotFoundException e) {
            
            e.printStackTrace();
        } 

        return new CommandResult(String.format(MESSAGE_REMINDER_TASK_SUCCESS, newReminder));
    }

    @Override
    public boolean canUndo() {
        return true;
    }

}
```
###### \java\seedu\inbx0\logic\internalcommands\ExpiredCommand.java
``` java
public class ExpiredCommand extends Command {
    
    private static final String MESSAGE_SUCCESS = "Successfully checked for expired tasks";
    public final Date currentDate;
    public final String currentTime;
    
    public ExpiredCommand() {
        Date currentDate = null;
        String currentTime = null;
        List<java.util.Date> current = new Parser().parse("now").get(0).getDates();
        SimpleDateFormat ft = new SimpleDateFormat ("HH:mm");
        
        currentTime = ft.format(current.get(0));
                
        try {
            currentDate = new Date("now");
            
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
                
        this.currentDate = currentDate;
        this.currentTime = currentTime;
    }
    
    public CommandResult execute() {
        assert model != null;
        model.checkExpiry(currentDate, currentTime);
        return new CommandResult(MESSAGE_SUCCESS);

    }

    @Override
    public boolean canUndo() {
        return false;
    }
}

```
###### \java\seedu\inbx0\logic\internalcommands\RemoveReminder.java
``` java
public class RemoveReminder extends Command {
    
    private static final String MESSAGE_SUCCESS = "Successfully checked for activated reminders";
    
    public RemoveReminder() {}
    
    public CommandResult execute() {
        assert model != null;
        model.checkReminders();
        return new CommandResult(MESSAGE_SUCCESS);

    }

    @Override
    public boolean canUndo() {
        return false;
    }
}
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    private String timeParse(final String dateTimeString) {
        Matcher matcher1 = DATE_TIME_FORMAT.matcher(dateTimeString.trim());
        Matcher matcher2 = DATE_TIME_FORMAT_2.matcher(dateTimeString.trim());
        Matcher matcher3 = DATE_TIME_FORMAT_3.matcher(dateTimeString.trim());
        Matcher matcher4 = DATE_TIME_FORMAT_4.matcher(dateTimeString.trim());
        Matcher matcher5 = DATE_TIME_FORMAT_5.matcher(dateTimeString.trim());
        Matcher matcher6 = DATE_TIME_FORMAT_6.matcher(dateTimeString.trim());

        if (matcher1.matches()) {
            return matcher1.group("time");
        }

        if (matcher2.matches()) {
            return matcher2.group("time");
        }

        if (matcher3.matches()) {
            return matcher3.group("time");
        }

        if (matcher4.matches()) {
            return matcher4.group("time");
        }

        if (matcher5.matches()) {
            return "";
        }

        if (matcher6.matches()) {
            return "";
        }

        return dateTimeString;
    }
    
    /**
     * Checks whether the string contains a date
     *
     * @param the string that the user inputs in s= or e= which
     *        may contain date and time together
     * @return the date
     */
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    private String dateParse(final String dateTimeString) {
        Matcher matcher1 = DATE_TIME_FORMAT.matcher(dateTimeString.trim());
        Matcher matcher2 = DATE_TIME_FORMAT_2.matcher(dateTimeString.trim());
        Matcher matcher3 = DATE_TIME_FORMAT_3.matcher(dateTimeString.trim());
        Matcher matcher4 = DATE_TIME_FORMAT_4.matcher(dateTimeString.trim());

        if (matcher1.matches()) {
            return matcher1.group("date");
        }

        if (matcher2.matches()) {
            return matcher2.group("date");
        }

        if (matcher3.matches()) {
            return matcher3.group("date");
        }

        if (matcher4.matches()) {
            return matcher4.group("date");
        }

        return dateTimeString;
    }

    /**
     * Extracts the new task's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(final String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst(" t=", "").split(" t="));
        return new HashSet<>(tagStrings);
    }

    /**
     * Parses arguments in the context of the edit task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    private Command prepareEdit(final String args) {
        final Matcher matcher = TASK_EDIT_DATA_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = parseIndex(matcher.group("targetIndex"));
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        String[] argumentsForEdit = new String[6];

        String arguments = matcher.group("arguments");

        if (arguments.length() == 0) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        if (arguments.trim().equals("float")) {
            argumentsForEdit[1] = "";
            argumentsForEdit[2] = "";
            argumentsForEdit[3] = "";
            argumentsForEdit[4] = "";

            try {
                return new EditCommand(index.get(), argumentsForEdit, null);
            } catch (IllegalValueException e) {
                return new IncorrectCommand(e.getMessage());
            }
        }

        Pattern editArguments = scanArgumentsAndBuildRegex(arguments);

        if (editArguments == null) {
            return new IncorrectCommand(
                    String.format(EditCommand.MESSAGE_INVALID_ARGUMENTS, EditCommand.MESSAGE_USAGE));
        }

        Matcher matcher2 = editArguments.matcher(arguments);
        if (matcher2.matches()) {
            if (arguments.contains(NAME)) {
                argumentsForEdit[0] = matcher2.group("name");
            }
            if (arguments.contains(START_DATE) && !arguments.contains(START_TIME)) {
                if (matcher2.group("startDate").equals("nil")) {
                    argumentsForEdit[1] = "";
                    argumentsForEdit[2] = "";
                } else {
                    argumentsForEdit[1] = dateParse(matcher2.group("startDate"));
                    argumentsForEdit[2] = timeParse(matcher2.group("startDate"));

                    Time getTime = null;
                    try {
                        getTime = new Time(argumentsForEdit[2]);
                    } catch (IllegalValueException e) {
                        e.printStackTrace();
                    }
                    if (argumentsForEdit[2].equals("") | getTime.getTime().equals(""))
                        argumentsForEdit[2] = null;

                }
            } else if (arguments.contains(START_DATE) && arguments.contains(START_TIME)) {
                if (matcher2.group("startDate").equals("nil") && matcher2.group("startTime").equals("nil")) {
                    argumentsForEdit[1] = "";
                    argumentsForEdit[2] = "";
                } else {
                    argumentsForEdit[1] = matcher2.group("startDate");
                    argumentsForEdit[2] = matcher2.group("startTime");
                }
            } else if (arguments.contains(START_TIME)) {
                if (matcher2.group("startTime").equals("nil")) {
                    argumentsForEdit[2] = "";
                } else {
                    argumentsForEdit[2] = matcher2.group("startTime");
                }
            }

            if (arguments.contains(END_DATE) && !arguments.contains(END_TIME)) {
                if (matcher2.group("endDate").equals("nil")) {
                    argumentsForEdit[3] = "";
                    argumentsForEdit[4] = "";
                } else {
                    argumentsForEdit[3] = dateParse(matcher2.group("endDate"));
                    argumentsForEdit[4] = timeParse(matcher2.group("endDate"));
                    Time getTime = null;
                    try {
                        getTime = new Time(argumentsForEdit[4]);
                    } catch (IllegalValueException e) {
                        e.printStackTrace();
                    }
                    if (argumentsForEdit[4].equals("") | getTime.getTime().equals(""))
                        argumentsForEdit[4] = null;
                }
            } else if (arguments.contains(END_DATE) && arguments.contains(END_TIME)) {
                if (matcher2.group("endDate").equals("nil") && matcher2.group("endTime").equals("nil")) {
                    argumentsForEdit[3] = "";
                    argumentsForEdit[4] = "";
                } else {
                    argumentsForEdit[3] = matcher2.group("endDate");
                    argumentsForEdit[4] = matcher2.group("endTime");
                }
            } else if (arguments.contains(END_TIME)) {
                if (matcher2.group("endTime").equals("nil")) {
                    argumentsForEdit[4] = "";
                } else {
                    argumentsForEdit[4] = timeParse(matcher2.group("endTime"));
                }
            }

            if (arguments.contains(IMPORTANCE)) {
                if (matcher2.group("level").equals("nil")) {
                    argumentsForEdit[5] = "";
                } else {
                    argumentsForEdit[5] = matcher2.group("level");
                }
            }
        }
        try {
            return new EditCommand(index.get(), argumentsForEdit, getTagsFromArgs(matcher2.group("tagArguments")));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    
    /**
     * Builds the regex pattern based on the user's input of parameters
     *
     * @param full command args string
     *            
     * @return the regex pattern
     */
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    private Pattern scanArgumentsAndBuildRegex(final String arguments) {
        String regex = "";

        if (arguments.contains(NAME)) {
            regex += " n=(?<name>[^=]+)";
        }
        if (arguments.contains(START_DATE)) {
            regex += " s=(?<startDate>[^=]+)";
        }
        if (arguments.contains(START_TIME)) {
            regex += " st=(?<startTime>[^=]+)";
        }
        if (arguments.contains(END_DATE)) {
            regex += " e=(?<endDate>[^=]+)";
        }

        if (arguments.contains(END_TIME)) {
            regex += " et=(?<endTime>[^=]+)";
        }

        if (arguments.contains(IMPORTANCE)) {
            regex += " i=(?<level>[^=]+)";
        }

        regex += "(?<tagArguments>(?: t=[^=]+)*)";

        Pattern editArguments = Pattern.compile(regex);

        Matcher matcher = editArguments.matcher(arguments);

        if (matcher.matches()) {
            return editArguments;
        } else {
            return null;
        }
    }

    /**
     * Parses arguments in the context of the add tag command.
     *
     * @param args full command args string
     * @return the prepared command
     */
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    private Command prepareMarkComplete(final String args) {
        final Matcher matcher = INDEX_NUMBER_ARGS_FORMAT.matcher(args.trim());
        final Matcher matcher2 = INDEX_NUM_TO_INDEX_NUM_ARGS_FORMAT.matcher(args.trim());

        if (!matcher.matches() && !matcher2.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCompleteCommand.MESSAGE_USAGE));
        }

        Set<Integer> indexNumSet;

        if (matcher2.matches()) {
            Integer front = Integer.valueOf(matcher2.group("first"));
            Integer back = Integer.valueOf(matcher2.group("last"));

            if (back < front | front.equals(back)) {
                return new IncorrectCommand(String.format(MarkCompleteCommand.MESSAGE_INVALID_ARGUMENTS,
                        MarkCompleteCommand.MESSAGE_USAGE));
            }
            Integer[] indexNumInteger = new Integer[back - front + 1];
            int index = 0;
            for (Integer i = front; i <= back; i++) {

                indexNumInteger[index] = i;
                index++;
            }

            indexNumSet = new HashSet<Integer>(Arrays.asList(indexNumInteger));

        } else {
            final String[] indexNumbers = matcher.group("numbers").split("\\s+");
            final int[] indexNum = Arrays.asList(indexNumbers).stream().mapToInt(Integer::parseInt).toArray();
            Integer[] indexNumInteger = IntStream.of(indexNum).boxed().toArray(Integer[]::new);
            indexNumSet = new HashSet<Integer>(Arrays.asList(indexNumInteger));
        }
        try {

            return new MarkCompleteCommand(indexNumSet);
        } catch (IllegalValueException e) {

            return new IncorrectCommand(e.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the Remind command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    private Command prepareRemind(String arguments) {
        final Matcher matcher = TASK_REMINDER_ARGS_FORMAT.matcher(arguments.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RemindCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = parseIndex(matcher.group("targetIndex"));
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RemindCommand.MESSAGE_USAGE));
        }

        int targetIndex = Integer.parseInt(matcher.group("targetIndex"));

        return new RemindCommand(targetIndex, matcher.group("startDate"));
    }

    /**
     * Parses arguments in the context of the sort task command.
     * 
     * @param args full command args string
     * @return the prepared command
     * @author A0148044J
     */
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    @Override
    public synchronized void editTask(ReadOnlyTask target, Task task) throws TaskNotFoundException, DuplicateTaskException {
        taskList.editTask(target, task);
        updateFilteredListToShowAll();
        indicateTaskListChanged();
    }
    
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    @Override
    public synchronized void markTaskComplete(ReadOnlyTask target, Task task) throws TaskNotFoundException {
        taskList.markTaskComplete(target, task);
        indicateTaskListChanged();
    }
    
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    @Override
    public synchronized void checkExpiry(Date currentDate, String currentTime) {
        if(taskList.checkExpiry(currentDate, currentTime))
            indicateTaskListChanged();
    }
    
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    @Override
    public synchronized void checkReminders() {
        if(taskList.checkReminders())
            indicateTaskListChanged();
    }
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredOverdueTaskList() {    
        updateFilteredOverdueTaskList();
        return new UnmodifiableObservableList<>(filteredOverdueTasks);
    }
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(String date, String preposition){
        if(preposition.equals(""))
            updateFilteredTaskList(new PredicateExpression(new StartOnAndEndOnDateQualifier(date)));
        else if(preposition.equals("overdue"))
            updateFilteredTaskList(new PredicateExpression(new OverdueTaskQualifier()));
        else
            updateFilteredTaskList(new PredicateExpression(new EndUntilDateQualifier(date)));
    }
    
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    @Override
    public void updateFilteredOverdueTaskList() {
        updateFilteredOverdueTaskList(new PredicateExpression(new OverdueTaskQualifier()));
    }
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    private class OverdueTaskQualifier implements Qualifier {
        
        OverdueTaskQualifier() {
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            return (task.getIsExpired() && !task.getIsCompleted() &&
                    task.getStartDate().value.equals("") && task.getStartTime().value.equals("") &&
                    !task.getEndDate().equals("") && !task.getEndDate().equals("")) | 
                    (task.getIsExpired() && !task.getIsCompleted() &&
                     task.getStartDate().value.equals("") && task.getStartTime().value.equals("") &&
                     !task.getEndDate().equals("") && task.getEndDate().equals(""));
        }
        
        @Override
        public String toString() {
            return "isExpired";
        }
    }
    
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    private class StartOnAndEndOnDateQualifier implements Qualifier {
        private String date;
        
        StartOnAndEndOnDateQualifier(String date) {
            this.date = date;
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            return (date.equals(task.getStartDate().value) | date.equals(task.getEndDate().value));
        }
        
        @Override
        public String toString() {
            return "date= " + date;
        }
    }
    
    private class EndUntilDateQualifier implements Qualifier {
        private String date;
        
        EndUntilDateQualifier(String date) {
            this.date = date;
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            Date today = null;
           
            boolean taskIsAfterCurrentDate = false;
            boolean taskIsBeforeDueDate = false;
            boolean isBeforeOrOnDueButAfterOrOnCurrent = false;
            try {
                today = new Date("today");
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
            
            int dueByNumberDate = Integer.parseInt(date.replaceAll("\\D+",""));
            int dueByDay = dueByNumberDate / 1000000;
            int dueByMonth = (dueByNumberDate / 10000) % 100;
            int dueByYear = dueByNumberDate % 10000;
             
            if(task.getEndDate().getYear() > today.getYear() |
              (task.getEndDate().getYear() == today.getYear() && task.getEndDate().getMonth() > today.getMonth()) |
              (task.getEndDate().getYear() == today.getYear() && task.getEndDate().getMonth() == today.getMonth() &&
              task.getEndDate().getDay() >= today.getDay()))       
                taskIsAfterCurrentDate = true;
            
            if((dueByYear > task.getEndDate().getYear()) |
               (dueByYear == task.getEndDate().getYear() && dueByMonth > task.getEndDate().getMonth()) |
               (dueByYear == task.getEndDate().getYear() && dueByMonth == task.getEndDate().getMonth() &&
               dueByDay >= task.getEndDate().getDay()))
                taskIsBeforeDueDate = true;
            
            if(taskIsAfterCurrentDate == true && taskIsBeforeDueDate == true)
                isBeforeOrOnDueButAfterOrOnCurrent = true;
           
            return isBeforeOrOnDueButAfterOrOnCurrent;
                   
        }
        
```
###### \java\seedu\inbx0\model\reminder\ReminderTask.java
``` java
public class ReminderTask {
    
    Toolkit toolkit;
    Timer timer;
    Date date;
    Time time;
    ReadOnlyTask task;
    boolean isAlive;
    
    public ReminderTask(Date date, Time time, ReadOnlyTask task, boolean isAlive) {
        toolkit = Toolkit.getDefaultToolkit();
        this.date = date;
        this.time = time;
        this.task = task;
        this.isAlive = true;
        
        Date currentDate = null;
        try {
            currentDate = new Date("now");
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        
        if(currentDate.value.equals(date.value)) {
            if(!("").equals(time.getTime())) {
            int reminderTime = Integer.parseInt(time.getTime().replaceAll("\\D+",""));
            int reminderHour = reminderTime / 100;
            int reminderMin = reminderTime % 100;
            
            Calendar calendar = Calendar.getInstance();
            calendar.set(Calendar.HOUR_OF_DAY, reminderHour);
            calendar.set(Calendar.MINUTE, reminderMin);
            calendar.set(Calendar.SECOND, 0);
            
            java.util.Date timerRemind = calendar.getTime();
            timer = new Timer();
            timer.schedule(new ReminderMessage(), timerRemind);
            }
            else
            {
                timer = new Timer();
                timer.schedule(new ReminderMessage(), 1);
            }
        }
    }
    
    /**
     * Copy constructor.
     * @throws IllegalValueException if not valid
     */
    public ReminderTask(final ReminderTask source) throws IllegalValueException {
        this(source.getStartDate(), source.getStartTime(),source.getReadableOnlyTask(), source.getIsAlive());
    }
    
    public Date getStartDate() {
        return date;
    }
    
    public Time getStartTime() {
        return time;
    }

    public ReadOnlyTask getReadableOnlyTask() {
        return task;
    }
    
    public boolean getIsAlive() {
        return isAlive;
    }
    
    public void setReadableOnlyTask(ReadOnlyTask task) {
       this.task = task;
    }
    
    /**
     * Format state as text for viewing.
     */
    public final String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append("Reminder")
                .append(" Start Date: ")
                .append(getStartDate())
                .append(" Start Time: ")
                .append(getStartTime());
        return builder.toString();
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReminderTask // this is first to avoid NPE below 
                && this.date.value.equals(((ReminderTask) other).date.value) // state checks here onwards
                && this.time.value.equals(((ReminderTask) other).time.value)
                && this.task.getName().equals(((ReminderTask) other).task.getName())
                && this.task.getStartDate().equals(((ReminderTask) other).task.getStartDate())
                && this.task.getStartTime().equals(((ReminderTask) other).task.getStartTime())
                && this.task.getEndDate().equals(((ReminderTask) other).task.getEndDate())
                && this.task.getEndTime().equals(((ReminderTask) other).task.getEndTime()));
    }
    
    class ReminderMessage extends TimerTask {
        public void run() {
            toolkit.beep();           
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Platform.runLater(() -> {
            EventsCenter.getInstance().post(new ShowReminderRequestEvent(task));
            });
            isAlive = false;
            timer.cancel();            
        }
    }
}
```
###### \java\seedu\inbx0\model\reminder\UniqueReminderList.java
``` java
public class UniqueReminderList implements Iterable<ReminderTask> {

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    @SuppressWarnings("serial")
    public static class DuplicateReminderException extends DuplicateDataException {
        protected DuplicateReminderException() {
            super("Operation would result in duplicate reminders");
        }
    }
    
    /**
     * Signals that an operation targeting a specified reminder in the list would fail because
     * there is no such matching reminder in the list.
     */
    @SuppressWarnings("serial")
    public static class ReminderNotFoundException extends Exception {}
    
    private final ObservableList<ReminderTask> internalList = FXCollections.observableArrayList();
    
    /**
     * Constructs empty ReminderList.
     */
    public UniqueReminderList() {}
    
    /**
     * java collections constructor, enforces no null or duplicate elements.
     */
    public UniqueReminderList(Collection<ReminderTask> reminders) throws DuplicateReminderException {
        CollectionUtil.assertNoNullElements(reminders);
        if (!CollectionUtil.elementsAreUnique(reminders)) {
            throw new DuplicateReminderException();
        }
        internalList.addAll(reminders);
    }
    /**
     * Varargs/array constructor, enforces no nulls or duplicates.
     */
    public UniqueReminderList(ReminderTask... reminders) throws DuplicateReminderException {
        assert !CollectionUtil.isAnyNull((Object[]) reminders);
        final List<ReminderTask> initialReminders = Arrays.asList(reminders);
        if (!CollectionUtil.elementsAreUnique(initialReminders)) {
            throw new DuplicateReminderException();
        }
        internalList.addAll(initialReminders);
    }
    
    /**
     * Copy constructor, insulates from changes in source.
     */
    public UniqueReminderList(UniqueReminderList source) {
        internalList.addAll(source.internalList); // insulate internal list from changes in argument
    }
    
    /**
     * java set constructor, enforces no nulls.
     */
    public UniqueReminderList(Set<ReminderTask> reminders) {
        CollectionUtil.assertNoNullElements(reminders);
        internalList.addAll(reminders);
    }
    /**
     * All reminders in this list as a Set. This set is mutable and change-insulated against the internal list.
     */
    public Set<ReminderTask> toSet() {
        return new HashSet<>(internalList);
    }
    
    
    /**
     * Adds a Reminder to the list.
     *
     * @throws DuplicateReminderException if the reminder to add is a duplicate of an existing reminder in the list.
     */
    public void add(ReminderTask toAdd) throws DuplicateReminderException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateReminderException();
        }
        internalList.add(toAdd);
    }
    
    
    /**
     * Adds every reminder from the argument list that does not yet exist in this list.
     */
    public void mergeFrom(UniqueReminderList reminders) {
        final Set<ReminderTask> alreadyInside = this.toSet();
        for (ReminderTask reminder : reminders) {
            if (!alreadyInside.contains(reminder)) {
                internalList.add(reminder);
            }
        }
    }
    
    /**
     * Returns true if the list contains an equivalent reminder as the given argument.
     */
    public boolean contains(ReminderTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }
    
    /**
     * Removes the equivalent Reminder from the list.
     *
     * @throws ReminderNotFoundException if no such reminder could be found in the list.
     */
    public boolean remove(ReminderTask toRemove) throws ReminderNotFoundException {
        assert toRemove != null;
        final boolean reminderFoundAndDeleted = internalList.remove(toRemove);
        if (!reminderFoundAndDeleted) {
            throw new ReminderNotFoundException();
        }
        return reminderFoundAndDeleted;
    }
    
    public ObservableList<ReminderTask> getInternalList() {
        return internalList;
    }
    
    @Override
    public Iterator<ReminderTask> iterator() {
        return internalList.iterator();
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueReminderList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueReminderList) other).internalList));
    }
    
    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

}
```
###### \java\seedu\inbx0\model\task\Date.java
``` java
public class Date {

    public static final String MESSAGE_DATE_CONSTRAINTS = "Date can either be a numeric string, alphanumeric string, or alphabet string \n"
                                                        + "Example: DD/MM/YYYY format OR 3rd Jan OR next year";
    public static final Pattern DATE_NUMERIC_VALIDATION_REGEX = Pattern.compile("(?<front>[0-9 ]+)[./-](?<middle>[0-9 ]+)[./-](?<back>[0-9 ]+)");
    public static final String DATE_NUMERIC_VALIDATION_REGEX_2 = "^[0-9]{8,8}$";
/*    public static final String DATE_ALPHANUMERIC_VALIDATION_REGEX = "(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)";
    public static final String DATE_ALPHABETICAL_VALIDATION_REGEX = "[\\p{Alpha} ]+";
    public static final String SPLIT_NUM_AND_ALPHABET_REGEX = "(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)";
*/
    public final String value;
    public final int day;
    public final int month;
    public final int year;
    public final String dayWord;
    public final String DDMMYYYYFormat;
    
    /**
     * Validates given start date.
     *
     * @throws IllegalValueException if given start date string is invalid.
     */
    
    public Date(String date) throws IllegalValueException {
        assert date != null;
        final Matcher matcher = DATE_NUMERIC_VALIDATION_REGEX.matcher(date.trim());
             
        if("".equals(date) | date.length() == 0 | date == null) {
            this.day = 0;
            this.month = 0;
            this.year = 0;
            this.value = "";
            this.dayWord = "";
            this.DDMMYYYYFormat = "";            
        }
        else if(date.matches(DATE_NUMERIC_VALIDATION_REGEX_2)) {
            
            String dateWithoutSpaces = date.replaceAll(" ","");
            int numberDate = Integer.parseInt(dateWithoutSpaces);

            if(dateWithoutSpaces.length() == 8) {
                this.day = numberDate / 1000000;
                this.month = (numberDate / 10000) % 100;
                this.year = numberDate % 10000;
                
                String nattyFormat = Integer.toString(month) + "/" + Integer.toString(day) + "/" + Integer.toString(year);

                List<java.util.Date> dates = new Parser().parse(nattyFormat).get(0).getDates();
                SimpleDateFormat ft = new SimpleDateFormat ("dd.MM.yyyy");
                SimpleDateFormat dayInWord = new SimpleDateFormat ("E, ");
                
                this.dayWord = dayInWord.format(dates.get(0));
                this.DDMMYYYYFormat = ft.format(dates.get(0));
                this.value = ft.format(dates.get(0)).replaceAll("\\D+","");
            }
            else
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        else if(matcher.matches()) {
            
            String dateFront = matcher.group("front").trim();
            String dateMiddle = matcher.group("middle").trim();
            String dateBack = matcher.group("back").trim();
            
            if(dateFront.length() == 4) {
                this.year = Integer.parseInt(dateFront);
                this.month = Integer.parseInt(dateMiddle); 
                this.day = Integer.parseInt(dateBack);
            }
            else if(dateFront.length() <= 0 | dateFront.length() > 4 | dateMiddle.length() <= 0 |
                    dateMiddle.length() > 2 | dateBack.length() < 2 | dateBack.length() > 4)
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
            else {
                this.day = Integer.parseInt(dateFront);
                this.month = Integer.parseInt(dateMiddle); 
                this.year = Integer.parseInt(dateBack);
            }
            
            String nattyFormat = Integer.toString(month) + "/" + Integer.toString(day) + "/" + Integer.toString(year);
            List<java.util.Date> dates = new Parser().parse(nattyFormat).get(0).getDates();
            SimpleDateFormat ft = new SimpleDateFormat ("dd.MM.yyyy");
            SimpleDateFormat dayInWord = new SimpleDateFormat ("E, ");
            
            this.dayWord = dayInWord.format(dates.get(0));
            this.DDMMYYYYFormat = ft.format(dates.get(0));
            
            this.value = ft.format(dates.get(0)).replaceAll("\\D+","");
            }
        else {
            try {
            List<java.util.Date> dates = new Parser().parse(date).get(0).getDates(); 
            
            SimpleDateFormat ft = new SimpleDateFormat ("dd.MM.yyyy");
            SimpleDateFormat dayInWord = new SimpleDateFormat ("E, ");
            SimpleDateFormat numericFormat = new SimpleDateFormat ("ddMMyyyy");
            this.DDMMYYYYFormat = ft.format(dates.get(0));
            this.value = numericFormat.format(dates.get(0));
            int digitsOnly = Integer.parseInt(DDMMYYYYFormat.replaceAll("\\D+",""));
            this.day = digitsOnly / 1000000;
            this.month = (digitsOnly / 10000) % 100;
            this.year = digitsOnly % 10000;
            this.dayWord = dayInWord.format(dates.get(0));  

            } catch (IndexOutOfBoundsException e) {
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
            }
            
        }
        
       
 /*       if (!isValidDate(date) &&  (date != "")) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }*/
        
    }
    
    /**
     * Returns true if a given string is a valid task date.
     */
//    public static boolean isValidDate(String test) {
//        return (test.matches(DATE_NUMERIC_VALIDATION_REGEX) && (test.length() == 8));
//    }
 /*       boolean numericCheck = false;
        boolean alphanumericCheck = false;
        boolean alphabeticalCheck = false;
        
        if(test.matches(DATE_NUMERIC_VALIDATION_REGEX) && (test.length() == 8)) {
            numericCheck = true;
        }
        
        if (test.matches(DATE_ALPHABETICAL_VALIDATION_REGEX)) {
            for (int i = 0; i < NUM_OF_STRINGS_IN_ALLOWED_DATE_EXPRESSIONS; i++) {
                
                if(test == ALLOWED_DATE_EXPRESSIONS[i])              
                    alphabeticalCheck = true;                
            }
   
            test = test.toLowerCase();
            String [] alphabeticalTestCheck = test.split(" ");
            
            if (alphabeticalTestCheck.length == 2) {
                boolean datePrepositionCheck = false;
                boolean dayNameCheck = false;
                for(int i = 0;  i < NUM_OF_STRINGS_IN_ALLOWED_DATE_PREPOSITIONS; i++) {
                    if(alphabeticalTestCheck[0] == ALLOWED_DATE_PREPOSITIONS[i])
                        datePrepositionCheck = true;
                }
                
                for(int i = 0; i < NUM_OF_STRINGS_IN_ALLOWED_DAY_NAMES; i++) {
                    if(alphabeticalTestCheck[1] == ALLOWED_DAY_NAMES[i])
                        dayNameCheck = true;
                }
                
                if(datePrepositionCheck == true && dayNameCheck == true)
                    alphabeticalCheck = true;
            }
            
        }
        
        if(test.matches(DATE_ALPHANUMERIC_VALIDATION_REGEX)) {
            test = test.replace(" ", "");
            test = test.toLowerCase();
            String [] alphanumericTestCheck = test.split(SPLIT_NUM_AND_ALPHABET_REGEX);
            
            if(alphanumericTestCheck.length == 2) {
                if(alphanumericTestCheck[0].matches("[a-zA-Z]+") && alphanumericTestCheck[1].matches("\\d+")) {
                    if(alphanumericTestCheck[1].length() == 1 | alphanumericTestCheck[1].length() == 2) {
                        for(int i = 0; i < NUM_OF_STRINGS_IN_ALLOWED_MONTH_NAMES; i++ ) {
                            if(alphanumericTestCheck[0] == ALLOWED_MONTH_NAMES[i])
                                alphanumericCheck = true;
                        }
                    }
                }
                
                if(alphanumericTestCheck[0].matches("\\d+") && alphanumericTestCheck[1].matches("[a-zA-Z]+")) {
                    if(alphanumericTestCheck[0].length() == 1 | alphanumericTestCheck[0].length() == 2) {
                        for(int i = 0; i < NUM_OF_STRINGS_IN_ALLOWED_MONTH_NAMES; i++ ) {
                            if(alphanumericTestCheck[1] == ALLOWED_MONTH_NAMES[i])
                                alphanumericCheck = true;
                        }
                    }
                }
            }
        } 
            
        return (numericCheck | alphanumericCheck | alphabeticalCheck);
    } */
    
    @Override
    public String toString() {      
        return value;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Date // instanceof handles nulls
                && this.value.equals(((Date) other).value)); // state check
    }
    
    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public String getDate() {
        return value;
    }
    
    /**
     * @return a string representation of date in YYYYMMDD format
     */
    public String getDateYYYYMMDDFormat() {
        if ("".equals(value)) {
            return value;      
        }
        return value.substring(4,8) + value.substring(2,4) + value.substring(0,2);
    }
    
    public String getTotalDate() {
        return dayWord + DDMMYYYYFormat;
    }
    
    public int getDay() {
        return day;
    }
    
    public int getMonth() {
        return month;
    }
    
    public int getYear() {
        return year;
    }
}
```
###### \java\seedu\inbx0\model\task\Importance.java
``` java
public class Importance {
    
    public static final String MESSAGE_IMPORTANCE_CONSTRAINTS = "Importance has to be alphabetical format and has three levels (green, yellow, red) \n"
                                                            + "Example: G OR yellow OR r";;
    public static final String IMPORTANCE_VALIDATION_REGEX = "[a-zA-Z]+";
    public static final int NUM_OF_STRINGS_IN_ALLOWED_IMPORTANCE_NAMES = 12;
    public static final String [] ALLOWED_IMPORTANCE_NAMES = new String [] {
                                                              "g", "G", "green", "Green",
                                                              "y", "Y", "yellow", "Yellow",
                                                               "r", "R", "red", "Red"                                                            
                                                             };
    
    public final String value;
    public final int level;
    
    /**
     * Validates given importance.
     *
     * @throws IllegalValueException if given start importance string is invalid.
     */
    
    public Importance(String importance) throws IllegalValueException {
        assert importance != null;
        String trimmedImportance = importance.trim();
        if("".equals(trimmedImportance) | trimmedImportance.length() == 0 | trimmedImportance == null) {
            this.value = "";
            this.level = 0;
        }
        else {
            if (!isValidImportance(trimmedImportance)) {
                throw new IllegalValueException(MESSAGE_IMPORTANCE_CONSTRAINTS);
            }
            else {
                this.value = changeStringIntoProperColorName(trimmedImportance);
        
                if ("Green".equals(value))
                    level = 1;
                else if("Yellow".equals(value))
                    level = 2;
                else if ("Red".equals(value))
                    level = 3;
                else
                    level = 0;
                } 
        }
    }
    
    private String changeStringIntoProperColorName(String trimmedImportance) {
        String importance = trimmedImportance;
        if("g".equals(importance) | "G".equals(importance) | "green".equals(importance))
            importance = "Green";
        else if ("y".equals(importance) | "Y".equals(importance) | "yellow".equals(importance))
            importance = "Yellow";
        else if ("r".equals(importance) | "R".equals(importance) | "red".equals(importance))
            importance = "Red";
        return importance;
    }

    /**
     * Returns true if a given string is a valid task start time.
     */
    public static boolean isValidImportance(String test) {
        
        if(test.matches(IMPORTANCE_VALIDATION_REGEX)) {
            if(Arrays.asList(ALLOWED_IMPORTANCE_NAMES).contains(test)) 
                return true;           
        }
        
        return false;
    }
    
    @Override
    public String toString() {
        return value;
    }
    
    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public String getLevel() {
        return value;
    }
    
    public int getNumberLevel() {
        return level;
    }
}
```
###### \java\seedu\inbx0\model\task\Time.java
``` java
public class Time {

    public static final String MESSAGE_TIME_CONSTRAINTS = "Time can either be a numeric string, alphanumeric string, or alphabet string \n"
                                                        + "Example: HH:MM format OR 3a (3am) OR 3 hours later";
    public static final String TIME_VALIDATION_REGEX = "\\d+";
    
    public final String value;
    
    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given start time string is invalid.
     * !isValidTime(time) &&
     */
    
    public Time(String time) throws IllegalValueException {
        assert time != null;
       
        if ( time.equals("") | time.length() == 0 | time == null) {
            this.value = "";
        }
        else {
                try{
                    SimpleDateFormat ft = new SimpleDateFormat ("HH:mm");
                    List<java.util.Date> getTime = new Parser().parse(time).get(0).getDates();
                    List<java.util.Date> current = new Parser().parse("now").get(0).getDates();
                    
                    if(ft.format(getTime.get(0)).equals(ft.format(current.get(0))))
                        this.value = "";
                    else
                        this.value = ft.format(getTime.get(0)); 
                } catch (IndexOutOfBoundsException e) {
                    throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
                }
        }
       
    }
    
    /**
     * Returns true if a given string is a valid task start time.
     */
    public static boolean isValidTime(String test) {
        boolean hourCheck = false;
        boolean minCheck = false;
        
        if(test.matches(TIME_VALIDATION_REGEX) && (test.length() == 4)) {
            if((Integer.parseInt(test) / 100) < 24) {
                hourCheck = true;
            }
            
            if((Integer.parseInt(test) % 100) < 60) {
                minCheck = true;
            }
        }
       
        return (hourCheck && minCheck);
    }
    
    @Override
    public String toString() {
        return value;
    }
    

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Time // instanceof handles nulls
                && this.value.equals(((Time) other).value)); // state check
    }
    
    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public String getTime() {
        return value;
    }
}
```
###### \java\seedu\inbx0\model\task\UniqueTaskList.java
``` java
    public boolean edit(ReadOnlyTask toEdit, Task toEditWith) throws TaskNotFoundException, DuplicateTaskException {
        assert toEdit != null;
        int editTaskIndex = internalList.indexOf(toEdit);
        if (editTaskIndex < 0) {
            throw new TaskNotFoundException();
        }
        
        if (contains(toEditWith)) {           
            if(internalList.indexOf(toEditWith) != editTaskIndex |
              ((toEdit.getName() == toEditWith.getName()) && 
               (toEdit.getStartDate().equals(toEditWith.getStartDate())) &&
               (toEdit.getStartTime().equals(toEditWith.getStartTime())) &&
               (toEdit.getEndDate().equals(toEditWith.getEndDate())) &&
               (toEdit.getEndTime().equals(toEditWith.getEndTime())) &&                
               (toEdit.getLevel().equals(toEditWith.getLevel())) &&
               (toEdit.getTags().equals(toEditWith.getTags()))))             
                throw new DuplicateTaskException();
        }       
        
        
        boolean taskEdited = false;
        final Task taskFoundAndEdited = internalList.set(editTaskIndex, toEditWith);  
        
        if(taskFoundAndEdited != null) 
            taskEdited = true;
        
        return taskEdited;
    }
    
    /**
     * Marks the equivalent task from the list as completed.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
```
###### \java\seedu\inbx0\model\task\UniqueTaskList.java
``` java
    public boolean markComplete(ReadOnlyTask toMarkComplete, Task completedTask) throws TaskNotFoundException {
        assert toMarkComplete != null;
        int markCompletedTaskIndex = internalList.indexOf(toMarkComplete);
        if (markCompletedTaskIndex < 0) {
            throw new TaskNotFoundException();
        }
        
        boolean taskMarkedCompleted = false;
        final Task taskFoundAndMarkedCompleted = internalList.set(markCompletedTaskIndex, completedTask);  
        
        if(taskFoundAndMarkedCompleted != null) 
            taskMarkedCompleted = true;
        
        return taskMarkedCompleted;
    }
    
    /**
     * Checks expiry and sets the boolean isExpired accordingly for the tasks in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
```
###### \java\seedu\inbx0\model\task\UniqueTaskList.java
``` java
    public boolean checkExpiry(Date currentDate, String currentTime) {
        if(internalList.isEmpty()) {
            return false;
        }
        
        boolean changed = false;
        for(Task t : internalList) { 
            if(t.getEndDate().value.length() != 0 && t.getEndTime().value.length() != 0) {        
                if((t.getEndDate().getYear() < currentDate.getYear()) |
               ((t.getEndDate().getYear() == currentDate.getYear()) && (t.getEndDate().getMonth() < currentDate.getMonth())) |
               ((t.getEndDate().getYear() == currentDate.getYear()) && (t.getEndDate().getMonth() == currentDate.getMonth())
                 && (t.getEndDate().getDay() < currentDate.getDay())) |
               (t.getEndDate().value.equals(currentDate.value) && (Integer.parseInt(t.getEndTime().value.replaceAll("\\D+","")) <= Integer.parseInt(currentTime.replaceAll("\\D+",""))))) {          
                    if(!t.getIsExpired()) {
                        t.setExpired(true);
                        changed = true;
                    }
                }
            }
            else if(t.getEndDate().value.length() != 0 && t.getEndTime().value.length() == 0) {
                    if((t.getEndDate().getYear() < currentDate.getYear()) |
                       ((t.getEndDate().getYear() == currentDate.getYear()) && (t.getEndDate().getMonth() < currentDate.getMonth())) |
                       ((t.getEndDate().getYear() == currentDate.getYear()) && (t.getEndDate().getMonth() == currentDate.getMonth())
                       && (t.getEndDate().getDay() < currentDate.getDay()))) {
                        if(t.getIsExpired() == false) {
                            t.setExpired(true);
                            changed = true;
                        }             
                    }
                }  
            }  
        return changed;
    }
    
    /**
     * Checks reminders and remove them if they have been activated.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
```
###### \java\seedu\inbx0\model\task\UniqueTaskList.java
``` java
    public boolean checkReminders() {
        if(internalList.isEmpty()) {
            return false;
        }
        
        boolean changed = false;
        for(Task t : internalList) { 
            UniqueReminderList reminders = t.getReminders();
            Iterator<ReminderTask> check = reminders.iterator();
            while(check.hasNext()) {
                if(check.next().getIsAlive() == false) {
                    check.remove();
                    changed = true;
                }
            }
          t.setReminders(reminders);
        }
        return changed;
    }
    
```
###### \java\seedu\inbx0\ui\InformationPanel.java
``` java
public class InformationPanel extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(InformationPanel.class);
    private static final String FXML = "InformationPanel.fxml";
    private AnchorPane placeHolderPane;
    private VBox mainPane;
    
    @FXML
    private ListView<ReminderTask> reminderListView;
    @FXML
    private Label name;
    @FXML
    private Label startDate;
    @FXML
    private Label startTime;
    @FXML
    private Label endDate;
    @FXML
    private Label endTime;
    @FXML
    private Label tags;
    
    
    public InformationPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        mainPane = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }
    
    public static InformationPanel load(Stage primaryStage, AnchorPane infoPanelPlaceholder,  ReadOnlyTask task){
        InformationPanel infoPanel = UiPartLoader.loadUiPart(primaryStage, infoPanelPlaceholder, new InformationPanel());
        logger.fine("Showing task info"); 
        infoPanel.configure(task);
        return infoPanel;
    }
    
    //void fillInnerParts() {
        //ReminderListPanelHolder = ReminderListPanel.load(primaryStage, reminderListPlaceholder, task);        
    //}

    public void displayInfo(ReadOnlyTask task) {
        name.setText(task.getName().getName());
        startDate.setText(task.getStartDate().getTotalDate());
        startTime.setText(task.getStartTime().getTime());
        endDate.setText(task.getEndDate().getTotalDate());
        endTime.setText(task.getEndTime().getTime());
        tags.setText(task.tagsString());
    }
    
    private void configure(ReadOnlyTask task){
        if(task != null) {
            displayInfo(task);
            UniqueReminderList uniqueReminderList = new UniqueReminderList(task.getReminders());
            Iterator<ReminderTask> check = uniqueReminderList.iterator();
            while(check.hasNext()) {
                if(check.next().getIsAlive() == false) {
                    check.remove();
                }
            }
            ObservableList<ReminderTask> reminderList = uniqueReminderList.getInternalList();
            setConnections(reminderList);
            addToPlaceholder();
        }
    }
    
    
    private void setConnections(ObservableList<ReminderTask> reminderList) {
        reminderListView.setItems(reminderList);
        reminderListView.setCellFactory(listView -> new ReminderListViewCell());
        
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        SplitPane.setResizableWithParent(reminderListView, false);
        placeHolderPane.getChildren().add(mainPane);
    }
    

    
    class ReminderListViewCell extends ListCell<ReminderTask> {

        public ReminderListViewCell() {
        }

        @Override
        protected void updateItem(ReminderTask reminder, boolean empty) {
            super.updateItem(reminder, empty);
            if (empty || reminder.getIsAlive() == false || reminder == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(ReminderListCard.load(reminder, getIndex() + 1).getLayout());
            }
        }
    }
}
```
###### \java\seedu\inbx0\ui\MainWindow.java
``` java
    @FXML
    public void handleOverdueTasks() {
        OverdueTaskWindow overdueTaskWindow = OverdueTaskWindow.load(primaryStage, logic);
        overdueTaskWindow.show();
    }
    
    public void show() {
        primaryStage.show();
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

    public InformationPanel getBottomReminderListPanel() {
        return this.bottomReminderListPanel;
    }

    public TaskListPanel getUpperTaskListPanel() {
        return this.upperTaskListPanel;
    }

    @FXML
    public void handleListToday() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDayTaskList("today"));
    }

    @FXML
    public void handleListMonday() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDayTaskList("Monday"));
    }

    @FXML
    public void handleListTuesday() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDayTaskList("Tuesday"));
    }

    @FXML
    public void handleListWednesday() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDayTaskList("Wednesday"));
    }

    @FXML
    public void handleListThursday() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDayTaskList("Thursday"));
    }

    @FXML
    public void handleListFriday() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDayTaskList("Friday"));
    }

    @FXML
    public void handleListSaturday() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDayTaskList("Saturday"));
    }

    @FXML
    public void handleListSunday() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDayTaskList("Sunday"));
    }

    @FXML
    public void handleListEvent() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredEventTaskList());
    }

    @FXML
    public void handleListFloating() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredFloatTaskList());
    }

    @FXML
    public void handleListDeadline() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDeadlineTaskList());
    }

    @FXML
    public void handleListRed() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredImportanceTaskList("Red"));
    }

    @FXML
    public void handleListYellow() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredImportanceTaskList("Yellow"));
    }

    @FXML
    public void handleListGreen() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredImportanceTaskList("Green"));
    }

    @FXML
    public void handleListNone() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredImportanceTaskList(""));
    }

    @FXML
    public void handleListComplete() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredDoneTaskList());
    }

    @FXML
    public void handleListIncomplete() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredToDoTaskList());
    }

    @FXML
    public void handleListExpire() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredOverdueTaskList());
    }

    @FXML
    public void handleListValid() {
        upperTaskListPanel = null;
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredBeforedueTaskList());
    }

    public void handleShowFilteredListRequestByShowCommand(String filterCondition) {
        if (filterCondition.equals("today")) {
            closeAllTitledPane();
            handleListToday();
        } else if (filterCondition.equals("Monday")) {
            DayTitledPane.setExpanded(true);
            handleListMonday();
        } else if (filterCondition.equals("Tuesday")) {
            DayTitledPane.setExpanded(true);
            handleListTuesday();
        } else if (filterCondition.equals("Wednesday")) {
            DayTitledPane.setExpanded(true);
            handleListWednesday();
        } else if (filterCondition.equals("Thursday")) {
            DayTitledPane.setExpanded(true);
            handleListThursday();
        } else if (filterCondition.equals("Friday")) {
            DayTitledPane.setExpanded(true);
            handleListFriday();
        } else if (filterCondition.equals("Saturday")) {
            DayTitledPane.setExpanded(true);
            handleListSaturday();
        } else if (filterCondition.equals("Sunday")) {
            DayTitledPane.setExpanded(true);
            handleListSunday();
        } else if (filterCondition.equals("Event")) {
            CategoryTitledPane.setExpanded(true);
            handleListEvent();
        } else if (filterCondition.equals("Floating")) {
            CategoryTitledPane.setExpanded(true);
            handleListFloating();
        } else if (filterCondition.equals("Deadline")) {
            CategoryTitledPane.setExpanded(true);
            handleListDeadline();
        } else if (filterCondition.equals("Red")) {
            ImportanceTitledPane.setExpanded(true);
            handleListRed();
        } else if (filterCondition.equals("Yellow")) {
            ImportanceTitledPane.setExpanded(true);
            handleListYellow();
        } else if (filterCondition.equals("Green")) {
            ImportanceTitledPane.setExpanded(true);
            handleListGreen();
        } else if (filterCondition.equals("None")) {
            ImportanceTitledPane.setExpanded(true);
            handleListNone();
        } else if (filterCondition.equals("Complete")) {
            CompletenessTitledPane.setExpanded(true);
            handleListComplete();
        } else if (filterCondition.equals("Incomplete")) {
            CompletenessTitledPane.setExpanded(true);
            handleListIncomplete();
        } else if (filterCondition.equals("Expire")) {
            ExpiredTitledPane.setExpanded(true);
            handleListExpire();
        } else if (filterCondition.equals("Valid")) {
            ExpiredTitledPane.setExpanded(true);
            handleListValid();
        }
    }

    public void handleReminder(ReadOnlyTask task) {
        ReminderWindow reminderWindow = ReminderWindow.load(primaryStage, task);
        reminderWindow.show();
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredTaskList());
    }
    
    public void handleShowNormalTaskList() {
        closeAllTitledPane();
        upperTaskListPanel = TaskListPanel.load(primaryStage, getUpperTaskListPlaceholder(),
                logic.getFilteredTaskList());
    }

    private void closeAllTitledPane() {
        DayTitledPane.setExpanded(false);
        CategoryTitledPane.setExpanded(false);
        ImportanceTitledPane.setExpanded(false);
        CompletenessTitledPane.setExpanded(false);
        ExpiredTitledPane.setExpanded(false);
    }

    public void displayReminderInfoPanel(ReadOnlyTask newSelection) {
        bottomReminderListPanel = InformationPanel.load(primaryStage, getReminderListPlaceholder(), newSelection);        
    }
}
```
###### \java\seedu\inbx0\ui\OverdueTaskWindow.java
``` java
public class OverdueTaskWindow extends UiPart {

    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String ICON = "/images/help_icon.png";
    private static final String FXML = "OverdueTaskWindow.fxml";
    private static final String TITLE = "Overdue Tasks";
    public static final int MIN_HEIGHT = 600;
    public static final int MIN_WIDTH = 450;

    private VBox mainPane;
    private Scene scene;
    private Stage dialogStage;
    private TaskListPanel taskListPanel;
    
    @FXML
    private AnchorPane taskListPanelPlaceholder;

    public static OverdueTaskWindow load(Stage primaryStage, Logic logic) {
        logger.fine("Showing overdue tasks.");
        OverdueTaskWindow overdueTaskWindow = UiPartLoader.loadUiPart(primaryStage, new OverdueTaskWindow());
        overdueTaskWindow.configure(logic);
        return overdueTaskWindow;
    }

    @Override
    public void setNode(Node node) {
        mainPane = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    private void configure(Logic logic){
        Stage dialogStage = new Stage();
        dialogStage.initModality(Modality.APPLICATION_MODAL);
        this.dialogStage = dialogStage;
        
        setTitle(TITLE);
        setIcon(dialogStage, ICON);
        setWindowMinSize();
        dialogStage.setResizable(false);
        scene = new Scene(mainPane);
        dialogStage.setScene(scene);
        taskListPanel = TaskListPanel.load(dialogStage, getTaskListPlaceholder(), logic.getFilteredOverdueTaskList());
        
    }
    

    public void show() {
        dialogStage.showAndWait();
    }
    
    public AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }
    
    public TaskListPanel getTaskListPanel() {
        return this.taskListPanel;
    }
    
    private void setTitle(String title) {
        dialogStage.setTitle(title);
    }
    
    private void setWindowMinSize() {
        dialogStage.setMinHeight(MIN_HEIGHT);
        dialogStage.setMinWidth(MIN_WIDTH);
    }
}
```
###### \java\seedu\inbx0\ui\ReminderListCard.java
``` java
public class ReminderListCard extends UiPart{

    private static final String FXML = "ReminderListCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label id;
    @FXML
    private Label startDate;
    @FXML
    private Label startTime;

    private ReminderTask reminder;
    private int displayedIndex;

    public static ReminderListCard load(ReminderTask reminder, int displayedIndex){
        ReminderListCard card = new ReminderListCard();
        card.reminder = reminder;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        id.setText(displayedIndex + ". ");
        startDate.setText(reminder.getStartDate().getTotalDate());
        startTime.setText(reminder.getStartTime().getTime()); 
             
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}

```
###### \java\seedu\inbx0\ui\ReminderWindow.java
``` java
public class ReminderWindow extends UiPart {
    
    private static final Logger logger = LogsCenter.getLogger(ReminderWindow.class);
    private static final String FXML = "ReminderWindow.fxml";
    private static final String ICON = "/images/help_icon.png";
    private static final String TITLE = "Reminder!";
    
    @FXML
    private Label name;
    @FXML
    private Label startDate;
    @FXML
    private Label startTime;
    @FXML
    private Label endDate;
    @FXML
    private Label endTime;
    @FXML
    private Button OkayButton;
    
    private ReadOnlyTask task;
    private Stage reminderStage;
    private VBox mainPane;
    
    public static ReminderWindow load(Stage primaryStage, ReadOnlyTask task){
        logger.fine("Showing reminders");
        ReminderWindow reminderWindow = UiPartLoader.loadUiPart(primaryStage, new ReminderWindow());
        reminderWindow.configure(task);
        return reminderWindow;
    }
    
    public void displayInfo() {
        name.setText(task.getName().getName());
        startDate.setText(task.getStartDate().getTotalDate());
        startTime.setText(task.getStartTime().getTime());
        endDate.setText(task.getEndDate().getTotalDate());
        endTime.setText(task.getEndTime().getTime());
    }
    
    private void configure(ReadOnlyTask task){
        this.task = task;        
        Scene scene = new Scene(mainPane);
        //Null passed as the parent stage to make it non-modal.
        reminderStage = createDialogStage(TITLE, null, scene);
        setIcon(reminderStage, ICON);
        displayInfo();
    }
    
    @Override
    public void setNode(Node node) {
        mainPane = (VBox) node;
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    public void show() {
        reminderStage.showAndWait();
    }
    
    @FXML
    public void handleCloseReminder() {
        reminderStage.close();
    }
    
    @FXML
    public void keyPressed(KeyEvent evt) {
        if(evt.getCode().equals(KeyCode.ENTER)) {
            handleCloseReminder();
        }
        
    }
}
```
###### \java\seedu\inbx0\ui\UiManager.java
``` java
    @Subscribe
    private void handleShowReminderEvent(ShowReminderRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleReminder(event.task);
    }
    
```
###### \resources\view\OverdueTaskWindow.fxml
``` fxml
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.control.TextField?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.inbx0.ui.OverdueTaskWindow">
	<stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
   		<VBox fx:id="taskList" minWidth="340" prefWidth="340" minHeight="555">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0"/>
                </padding>
               <children>
                  <AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS"/>
               </children>
         </VBox>
    </children>
 </VBox>       
```
