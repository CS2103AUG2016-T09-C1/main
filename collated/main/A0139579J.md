# A0139579J
###### \java\seedu\inbx0\commons\events\ui\ShowReminderRequestEvent.java
``` java
/**
 * An event requesting to display the reminder.
 */
public class ShowReminderRequestEvent extends BaseEvent {
    
    public final ReadOnlyTask task;

    public ShowReminderRequestEvent(ReadOnlyTask task) {
        this.task = task;
    }
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\inbx0\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the tasklist.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the tasklist. \n"
            + "1. Event Task \n"
            + "Parameters: NAME s=STARTDATE st=STARTTIME e=ENDDATE et=ENDTIME [i=IMPORTANCE] [t=TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " homework s=tomorrow st=9a e=next week et=9a i=r t=CS2103 t=project \n \n"
            + "2. Floating Task \n"
            + "Parameters: NAME [i=IMPORTANCE] [t=TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " read shakespeare i=r t=Hamlet t=Romeo \n \n"
            + "3. Deadline Task \n"
            + "Parameters: NAME e=ENDDATE et=ENDTIME [i=IMPORTANCE] [t=TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " complete project e=next month et=10a i=r t=Hamlet t=Romeo \n";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the tasklist";

    private final Task toAdd;

    /**
     * AddCommand constructor for Events with Importance
     *
     * @throws IllegalValueException if any of the values are invalid
     */
    public AddCommand(String name, String startDate, String startTime, String endDate, String endTime, String level, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
            new Name(name),
            new Date(startDate),
            new Time(startTime),
            new Date(endDate),
            new Time(endTime),
            new Importance(level),
            new UniqueTagList(tagSet),
            new UniqueReminderList()
        );
    }
    
    /**
     * AddCommand constructor for Events without Importance
     *
     * @throws IllegalValueException if any of the values are invalid
     */
    public AddCommand(String name, String startDate, String startTime, String endDate, String endTime, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
            new Name(name),
            new Date(startDate),
            new Time(startTime),
            new Date(endDate),
            new Time(endTime),
            new Importance(""),
            new UniqueTagList(tagSet),
            new UniqueReminderList()
        );
    }
    
    /**
     * AddCommand constructor for Floating Tasks with Importance
     *
     * @throws IllegalValueException if any of the values are invalid
     */
    public AddCommand(String name, String level, Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
            new Name(name),
            new Date(""),
            new Time(""),
            new Date(""),
            new Time(""),
            new Importance(level),
            new UniqueTagList(tagSet),
            new UniqueReminderList()
        );
    }
    
    /**
     * AddCommand constructor for Floating Tasks without Importance
     *
     * @throws IllegalValueException if any of the values are invalid
     */
    public AddCommand(String name, Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
            new Name(name),
            new Date(""),
            new Time(""),
            new Date(""),
            new Time(""),
            new Importance(""),
            new UniqueTagList(tagSet),
            new UniqueReminderList()
        );
    } 
    
    /**
     * AddCommand constructor for Deadline Tasks with Importance.
     *
     * @throws IllegalValueException if any of the values are invalid
     */
    public AddCommand(String name, String endDate, String endTime, String level, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
            new Name(name),
            new Date(""),
            new Time(""),
            new Date(endDate),
            new Time(endTime),
            new Importance(level),
            new UniqueTagList(tagSet),
            new UniqueReminderList()
        );
    }
    
    /**
     * AddCommand constructor for Deadline Tasks without Importance.
     *
     * @throws IllegalValueException if any of the values are invalid
     */
    public AddCommand(String name, String endDate, String endTime, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
            new Name(name),
            new Date(""),
            new Time(""),
            new Date(endDate),
            new Time(endTime),
            new Importance(""),
            new UniqueTagList(tagSet),
            new UniqueReminderList()
        );
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            indicateCloseAllTitledpanesEvent();
            indicateJumpToTaskRequestEvent(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }
    
```
###### \java\seedu\inbx0\logic\commands\EditCommand.java
``` java
/**
 * Edits a task identified using it's last displayed index from the tasklist.
 */
public class EditCommand extends Command {
    
    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) [n=NAME] [s=STARTDATE] [st=STARTTIME] \n"
            + "[e=ENDDATE] [et=ENDTIME] [i=IMPORTANCE] [t=TAG]... (one optional parameter is required)\n"
            + "Example: " + COMMAND_WORD + " 1 s=tomorrow st=9a e=next week et=9a i=r t=CS2103 t=project \n \n"
            + "You can also change an event or a deadline task to a floating task \n"
            + "Parameters: INDEX (must be a positive integer) \n"
            + "Example: " + COMMAND_WORD + " 1 float \n";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the tasklist";
    public static final String MESSAGE_INVALID_ARGUMENTS = "The arguments provided are invalid.";
    public static final int TOTAL_NUMBER_OF_ARGUMENTS = 6;
    public static final int TASK_NAME = 0;
    public static final int TASK_START_DATE = 1;
    public static final int TASK_START_TIME = 2;
    public static final int TASK_END_DATE = 3;
    public static final int TASK_END_TIME = 4;
    public static final int TASK_IMPORTANCE = 5;
    
    public final int targetIndex;
    public String [] editArguments;
    public UniqueTagList tags;

    public EditCommand(int targetIndex, String [] argumentsToEdit, Set<String> tags) throws IllegalValueException {
        
        this.targetIndex = targetIndex;
        
        if(tags == null) {
            this.tags = null;
        }
        else {
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : tags) {
                tagSet.add(new Tag(tagName));
            }
            
            UniqueTagList editedTags = null;
            
            if(!tagSet.isEmpty()) {
                editedTags = new UniqueTagList(tagSet);
            }
         
            this.tags = editedTags;
        }
        this.editArguments = argumentsToEdit;    
    }
    
    /**
     * Retrieves the original tag list from the task that the user wants to edit.
     */
    private UniqueTagList obtainUniqueTagList(ReadOnlyTask taskToEdit) {
        
      UniqueTagList originalTagList = taskToEdit.getTags();
            
      return originalTagList;
    }
    
    /**
     * Retrieves the original reminder list from the task that the user wants to edit.
     */
    private UniqueReminderList obtainUniqueReminderList(ReadOnlyTask taskToEdit) {
        
        UniqueReminderList originalReminderList = taskToEdit.getReminders();
              
        return originalReminderList;
    }
    
    /**
     * Updates all the reminders in the reminder list from so that it displays the edited task.
     */
    private Task updateReminders(Task toEditWith) {
        Task newTask = toEditWith;
        UniqueReminderList reminders = toEditWith.getReminders();
        for(ReminderTask r: reminders) {
            r.setReadableOnlyTask(newTask);
        }
        toEditWith.setReminders(reminders);
        Task newUpdatedTask = toEditWith;
        
        return newUpdatedTask;
        
    }

    /**
     * Retrieves the remaining arguments from the task that the user wishes to be kept the same.
     */
    private String[] obtainArguments(String[] editArguments, ReadOnlyTask taskToEdit) {
       
        String [] originalArguments = new String[TOTAL_NUMBER_OF_ARGUMENTS];
                    
        originalArguments[TASK_NAME] = taskToEdit.getName().getName();
        originalArguments[TASK_START_DATE] = taskToEdit.getStartDate().getDate();
        originalArguments[TASK_START_TIME] = taskToEdit.getStartTime().getTime();
        originalArguments[TASK_END_DATE] = taskToEdit.getEndDate().getDate();
        originalArguments[TASK_END_TIME] = taskToEdit.getEndTime().getTime();
        originalArguments[TASK_IMPORTANCE] = taskToEdit.getLevel().getLevel();
            
        for(int i = 0; i < TOTAL_NUMBER_OF_ARGUMENTS; i++) {
            if(editArguments[i] == null)
                editArguments[i] = originalArguments[i];                       
        }
        
        return editArguments;
    }
    
    /**
     * Creates the task with the updated arguments or tags that the user inputs
     *
     * @throws IllegalValueException if any of the values are invalid
     */
    private Task createToEditWithTask(String[] editArguments, UniqueTagList tags, UniqueReminderList reminders) throws IllegalValueException {
        Task toEditWith = new Task (
                new Name(editArguments[TASK_NAME]),
                new Date(editArguments[TASK_START_DATE]),
                new Time(editArguments[TASK_START_TIME]),
                new Date(editArguments[TASK_END_DATE]),
                new Time(editArguments[TASK_END_TIME]),
                new Importance(editArguments[TASK_IMPORTANCE]),
                tags,
                reminders
                );
        return toEditWith;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);
        this.editArguments = obtainArguments(editArguments, taskToEdit);
        
        if(tags == null)
            this.tags = obtainUniqueTagList(taskToEdit);
        
        UniqueReminderList reminders = obtainUniqueReminderList(taskToEdit);
        
        Task toEditWith = null;
        try {
            toEditWith = createToEditWithTask(editArguments, tags, reminders);
        } catch (IllegalValueException e1) {
            return new CommandResult(String.format(MESSAGE_INVALID_ARGUMENTS, MESSAGE_USAGE));
        }
        
        Task updatedReminders = updateReminders(toEditWith);
        
        try {
            model.editTask(taskToEdit, updatedReminders);
            indicateJumpToTaskRequestEvent(taskToEdit);
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        } catch (UniqueTaskList.DuplicateTaskException e ) {    
            return new CommandResult(MESSAGE_DUPLICATE_TASK);            
        }

        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, toEditWith));
    }


    @Override
    public boolean canUndo() {
        return true;
    }
}
```
###### \java\seedu\inbx0\logic\commands\ListCommand.java
``` java
/**
 * Lists all tasks in the tasks to the user.
 * or tasks that are overdue
 * or tasks associated with the date
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS = "Listed all tasks";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": \n 1. Lists all tasks associated with the date and "
            + "displays them as a list with index numbers.\n"
            + "Without any parameters, it will display all undone tasks.\n"
            + "Parameters: [DATE]\n"
            + "Example: " + COMMAND_WORD + " today\n"
            + "2. Lists all tasks that are due to a certain date \n"
            + "Parameters: due DATE\n"
            + "Example: " + COMMAND_WORD + " due next week\n"
            + "3. Lists all tasks that are overdue \n"
            + "Example: " + COMMAND_WORD + " overdue\n";
    
    private final String checkDate;
    private final String preposition;
    private static final Pattern TASKS_DUE_UNTIL_DATE_LIST_FORMAT = Pattern.compile(" due (?<date>[^$]+)");
    
    /**
     * ListCommand constructor to display all incomplete tasks
     */
    public ListCommand() {
        this.checkDate = "";
        this.preposition = "";
    }

    public ListCommand(String arguments) throws IllegalValueException {
        final Matcher matcher = TASKS_DUE_UNTIL_DATE_LIST_FORMAT.matcher(arguments);
        if(matcher.matches()) {
            this.preposition = "due";
            Date checkDate = new Date(matcher.group("date"));
            this.checkDate = checkDate.value;
            
        }
        else if(arguments.trim().equals("overdue")) {
            this.checkDate = "";
            this.preposition = "overdue";
        }
        else {
            Date checkDate = new Date (arguments.trim());
            this.checkDate = checkDate.value;
            this.preposition = "";
        }
    }

    @Override
    public CommandResult execute() {
        if(checkDate.equals("") && preposition.equals("")) {
            model.updateFilteredTaskListByCompleteness(false);
            indicateCloseAllTitledpanesEvent();
            return new CommandResult(MESSAGE_SUCCESS);
        } else {
            model.updateFilteredTaskList(checkDate, preposition);
            indicateCloseAllTitledpanesEvent();
            return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        }       
    }

    @Override
    public boolean canUndo() {
        return false;
    }
}
```
###### \java\seedu\inbx0\logic\commands\MarkCompleteCommand.java
``` java
/**
 * Marks a task identified using it's last displayed index from the tasklist as completed.
 */
public class MarkCompleteCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing as completed.\n"
            + "Parameters: INDEX (must be a positive integer and can be more than one input given)\n"
            + "Example: " + COMMAND_WORD + " 1 2 3";

    public static final String MESSAGE_TASK_ALREADY_COMPLETED = "One or more tasks are already completed";
    public static final String MESSAGE_INVALID_ARGUMENTS = "The arguments provided are invalid.";

    public final List<Integer> indexNum;

    public MarkCompleteCommand(Set<Integer> indexNumSet) throws IllegalValueException {
    	validateSet(indexNumSet);
        this.indexNum = new ArrayList<Integer> (indexNumSet);
        sortIndexNumInDescendingOrder();
    }

    /**
     * Checks if the user has input any numerical values
     */
    private void validateSet(Set<Integer> indexNumSet) throws IllegalValueException {
        if(indexNumSet.isEmpty())
            throw new IllegalValueException(MESSAGE_INVALID_ARGUMENTS);        
    }
    
    /**
     * Sorts the set of numbers in descending order in preparation to mark them as complete
     */
    private void sortIndexNumInDescendingOrder() {
    	indexNum.sort(new IndexComparator());
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        
        for(Integer i : indexNum) {
            if (lastShownList.size() < i) {
                indicateAttemptToExecuteIncorrectCommand();
                return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
        }
        
        for(Integer i : indexNum) {
            ReadOnlyTask toMarkTaskCompleted = lastShownList.get(i - 1);
            Task completedTask = null;
            
            if(toMarkTaskCompleted.getIsCompleted()) {
                return new CommandResult(MESSAGE_TASK_ALREADY_COMPLETED);
            }
            try {
                completedTask = new Task (
                    new Name(toMarkTaskCompleted.getName().getName()),
                    new Date(toMarkTaskCompleted.getStartDate().getDate()),
                    new Time(toMarkTaskCompleted.getStartTime().getTime()),
                    new Date(toMarkTaskCompleted.getEndDate().getDate()),
                    new Time(toMarkTaskCompleted.getEndTime().getTime()),
                    new Importance(toMarkTaskCompleted.getLevel().getLevel()),
                    toMarkTaskCompleted.getTags(),
                    toMarkTaskCompleted.getReminders()
                    );
            } catch (IllegalValueException e) {
                return new CommandResult(String.format(MESSAGE_INVALID_ARGUMENTS, MESSAGE_USAGE));
            }
            
            completedTask.setCompleted(true);
            
            try {
                model.markTaskComplete(toMarkTaskCompleted, completedTask);
            } catch (TaskNotFoundException tnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        return new CommandResult(getMessageForTasksCompletedSummary(indexNum.size()));       
    }


    @Override
    public boolean canUndo() {
        return true;
    }
    
```
###### \java\seedu\inbx0\logic\commands\RemindCommand.java
``` java
/**
 * Adds a reminder for the task identified using it's last displayed index from the tasklist.
 */
public class RemindCommand extends Command {

    public static final String COMMAND_WORD = "rem";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Adds a reminder for the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX s=[START DATE] [START TIME] ( Index must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 s=5 minutes from now";

    public static final String MESSAGE_REMINDER_TASK_SUCCESS = "Added Reminder for Task: %1$s";
    public static final String MESSAGE_REMINDER_CONSTRAINTS = "The reminder date or time is invalid.";
    public static final String MESSAGE_DUPLICATE_REMINDER = "There is already a reminder during that time.";
    public static final int TOTAL_NUMBER_OF_ARGUMENTS = 6;
    private static final int TASK_NAME = 0;
    private static final int TASK_START_DATE = 1;
    private static final int TASK_START_TIME = 2;
    private static final int TASK_END_DATE = 3;
    private static final int TASK_END_TIME = 4;
    private static final int TASK_IMPORTANCE = 5;
    
    public final int targetIndex;
    public final Date startDate;
    public final Time startTime;

    public RemindCommand(int targetIndex, String date) {
        this.targetIndex = targetIndex;
        
        Date startDate = null;
        Time startTime = null;
        try {
            startDate = new Date(date);
            startTime = new Time(date);
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        
        this.startDate = startDate;
        this.startTime = startTime;
    }
    
    /**
     * Checks if the user has given a valid date and time
     */
    private boolean isValidDateAndTime(Date date, Time time) {               
        Date currentDate = null;
        try {
          currentDate = new Date("now");
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        
        if(currentDate.getDate().equals(date.getDate())) {
           return isValidTime(time);
        } else
           return isValidDate(currentDate, date);      
    }
    
    /**
     * Checks if the start time of the reminder has already passed
     */
    private boolean isValidTime(Time time) {
        boolean timeCheck = false;
        String current = Time.getCurrentTime();
        int currentTime = Integer.parseInt(current.replaceAll("\\D+",""));
        
        int currentHour = currentTime / 100;
        int currentMin = currentTime % 100;
        
        if (time == null) {
            timeCheck = false;
        }
        if (("").equals(time.value)) {
            timeCheck = true;
        } else {
            
            int reminderTime = Integer.parseInt(time.getTime().replaceAll("\\D+",""));
            int reminderHour = reminderTime / 100;
            int reminderMin = reminderTime % 100;
            
            if((reminderHour > currentHour) |
               (reminderHour == currentHour && reminderMin > currentMin))
                timeCheck = true;       
        }       
       return timeCheck; 
    }
    
    /**
     * Checks if the start date of the reminder has already passed
     */
    private boolean isValidDate(Date currentDate, Date date) {
        boolean dateCheck = false;
        int currentDay = currentDate.getDay();
        int currentMonth = currentDate.getMonth();
        int currentYear = currentDate.getYear();
        
        int reminderDay = date.getDay();
        int reminderMonth = date.getMonth();
        int reminderYear = date.getYear();
        
        if ((reminderYear > currentYear) |
           (reminderYear == currentYear && reminderMonth > currentMonth) |
           (reminderYear == currentYear && reminderMonth == currentMonth && reminderDay > currentDay)) 
            dateCheck = true;
        return dateCheck;
    }
    
    /**
     * Creates the task with the new reminder
     *
     * @throws IllegalValueException if any of the values are invalid or if there is a duplicate reminder
     */
    private Task createTaskWithReminder(ReadOnlyTask taskToAddReminder, ReminderTask newReminder) throws IllegalValueException {
        String [] arguments = new String [TOTAL_NUMBER_OF_ARGUMENTS];
        arguments = obtainArguments(arguments, taskToAddReminder);
        UniqueTagList tags = obtainUniqueTagList(taskToAddReminder);
        UniqueReminderList reminders = addReminder(taskToAddReminder, newReminder);
        
        Task taskWithReminder = new Task (
            new Name(arguments[TASK_NAME]),
            new Date(arguments[TASK_START_DATE]),
            new Time(arguments[TASK_START_TIME]),
            new Date(arguments[TASK_END_DATE]),
            new Time(arguments[TASK_END_TIME]),
            new Importance(arguments[TASK_IMPORTANCE]),
            tags,
            reminders
            );
        return taskWithReminder;
    }
    
    /**
     * Retrieves the arguments from the original task
     */
    private String[] obtainArguments(String[] arguments, ReadOnlyTask taskToAddReminder) {
        
        String [] originalArguments = new String[TOTAL_NUMBER_OF_ARGUMENTS];
                    
        originalArguments[TASK_NAME] = taskToAddReminder.getName().getName();
        originalArguments[TASK_START_DATE] = taskToAddReminder.getStartDate().getDate();
        originalArguments[TASK_START_TIME] = taskToAddReminder.getStartTime().getTime();
        originalArguments[TASK_END_DATE] = taskToAddReminder.getEndDate().getDate();
        originalArguments[TASK_END_TIME] = taskToAddReminder.getEndTime().getTime();
        originalArguments[TASK_IMPORTANCE] = taskToAddReminder.getLevel().getLevel();
            
        for (int i = 0; i < TOTAL_NUMBER_OF_ARGUMENTS; i++) {
            if (arguments[i] == null)
                arguments[i] = originalArguments[i];                       
        }
        
        return arguments;
    }
    
    /**
     * Retrieves the original tag list from the task.
     */
    private UniqueTagList obtainUniqueTagList(ReadOnlyTask taskToAddReminder) {       
        UniqueTagList originalTagList = taskToAddReminder.getTags();            
        return originalTagList;
    }
    
    /**
     * Adds the new reminder to the existing reminder list
     */
    private UniqueReminderList addReminder(ReadOnlyTask taskToAddReminder, ReminderTask newReminder) throws DuplicateReminderException {
        UniqueReminderList originalReminderList = taskToAddReminder.getReminders();
        originalReminderList.add(newReminder);
        return originalReminderList;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        
        if (!isValidDateAndTime(startDate, startTime)) 
            return new CommandResult(MESSAGE_REMINDER_CONSTRAINTS);
        
        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToAddReminder = lastShownList.get(targetIndex - 1);
        
        ReminderTask newReminder = new ReminderTask(startDate, startTime, taskToAddReminder, true);
  
        Task withReminder = null;
        try {
            withReminder = createTaskWithReminder(taskToAddReminder, newReminder);
            EventsCenter.getInstance().post(new TaskPanelSelectionChangedEvent(withReminder));
        } catch (DuplicateReminderException d) {
            newReminder.cancel();
            return new CommandResult(MESSAGE_DUPLICATE_REMINDER);
        } catch (IllegalValueException e1) {
            return new CommandResult(MESSAGE_USAGE);
        } 
        try {
            model.editTask(taskToAddReminder, withReminder);
        } catch (DuplicateTaskException | TaskNotFoundException e) {       
            e.printStackTrace();
        } 

        return new CommandResult(String.format(MESSAGE_REMINDER_TASK_SUCCESS, newReminder));
    }

    @Override
    public boolean canUndo() {
        return true;
    }
}
```
###### \java\seedu\inbx0\logic\internalcommands\ExpiredCommand.java
``` java
/**
 * Checks tasks in the tasklist and determines whether the task has expired
 */
public class ExpiredCommand extends Command {
    
    private static final String MESSAGE_SUCCESS = "Successfully checked for expired tasks";
    public final Date currentDate;
    public final String currentTime;
    
    public ExpiredCommand() {
        Date currentDate = null;
        String currentTime = Time.getCurrentTime();
        
        try {
            currentDate = new Date("now");
            
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
                
        this.currentDate = currentDate;
        this.currentTime = currentTime;
    }
    
    public CommandResult execute() {
        assert model != null;
        model.checkExpiry(currentDate, currentTime);
        return new CommandResult(MESSAGE_SUCCESS);

    }

    @Override
    public boolean canUndo() {
        return false;
    }
}

```
###### \java\seedu\inbx0\logic\internalcommands\RemoveReminder.java
``` java
/**
 * Checks tasks in the tasklist and removes reminders that have already been activated
 */
public class RemoveReminder extends Command {
    
    private static final String MESSAGE_SUCCESS = "Successfully checked for activated reminders";
    
    public CommandResult execute() {
        assert model != null;
        model.checkReminders();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    @Override
    public boolean canUndo() {
        return false;
    }
}
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    /**
     * Checks whether the string contains a time
     *
     * @param the string that the user inputs in s= or e= which
     *        may contain date and time together
     * @return the time
     */  
    private String timeParse(final String dateTimeString) {
        Matcher matcher1 = DATE_TIME_FORMAT.matcher(dateTimeString.trim());
        Matcher matcher2 = DATE_TIME_FORMAT_2.matcher(dateTimeString.trim());
        Matcher matcher3 = DATE_TIME_FORMAT_3.matcher(dateTimeString.trim());
        Matcher matcher4 = DATE_TIME_FORMAT_4.matcher(dateTimeString.trim());
        Matcher matcher5 = DATE_TIME_FORMAT_5.matcher(dateTimeString.trim());
        Matcher matcher6 = DATE_TIME_FORMAT_6.matcher(dateTimeString.trim());

        if (matcher1.matches()) {
            return matcher1.group("time");
        }

        if (matcher2.matches()) {
            return matcher2.group("time");
        }

        if (matcher3.matches()) {
            return matcher3.group("time");
        }

        if (matcher4.matches()) {
            return matcher4.group("time");
        }

        if (matcher5.matches()) {
            return "";
        }

        if (matcher6.matches()) {
            return "";
        }

        return dateTimeString;
    }
    
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    /**
     * Checks whether the string contains a date
     *
     * @param the string that the user inputs in s= or e= which
     *        may contain date and time together
     * @return the date
     */
    private String dateParse(final String dateTimeString) {
        Matcher matcher1 = DATE_TIME_FORMAT.matcher(dateTimeString.trim());
        Matcher matcher2 = DATE_TIME_FORMAT_2.matcher(dateTimeString.trim());
        Matcher matcher3 = DATE_TIME_FORMAT_3.matcher(dateTimeString.trim());
        Matcher matcher4 = DATE_TIME_FORMAT_4.matcher(dateTimeString.trim());

        if (matcher1.matches()) {
            return matcher1.group("date");
        }

        if (matcher2.matches()) {
            return matcher2.group("date");
        }

        if (matcher3.matches()) {
            return matcher3.group("date");
        }

        if (matcher4.matches()) {
            return matcher4.group("date");
        }

        return dateTimeString;
    }
    
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    /**
     * Builds the regex pattern based on the user's input of parameters
     *
     * @param full command args string
     *            
     * @return the regex pattern
     */
    private Pattern scanArgumentsAndBuildRegex(final String arguments) {
        String regex = "";

        if (arguments.contains(NAME)) {
            regex += " n=(?<name>[^=]+)";
        }
        if (arguments.contains(START_DATE)) {
            regex += " s=(?<startDate>[^=]+)";
        }
        if (arguments.contains(START_TIME)) {
            regex += " st=(?<startTime>[^=]+)";
        }
        if (arguments.contains(END_DATE)) {
            regex += " e=(?<endDate>[^=]+)";
        }

        if (arguments.contains(END_TIME)) {
            regex += " et=(?<endTime>[^=]+)";
        }

        if (arguments.contains(IMPORTANCE)) {
            regex += " i=(?<level>[^=]+)";
        }

        regex += "(?<tagArguments>(?: t=[^=]+)*)";

        Pattern editArguments = Pattern.compile(regex);

        Matcher matcher = editArguments.matcher(arguments);

        if (matcher.matches()) {
            return editArguments;
        } else {
            return null;
        }
    }
    
```
###### \java\seedu\inbx0\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the Remind command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareRemind(String arguments) {
        final Matcher matcher = TASK_REMINDER_ARGS_FORMAT.matcher(arguments.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RemindCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = parseIndex(matcher.group("targetIndex"));
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RemindCommand.MESSAGE_USAGE));
        }

        int targetIndex = Integer.parseInt(matcher.group("targetIndex"));

        return new RemindCommand(targetIndex, matcher.group("startDate"));
    }
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    /**
     * Edits a task in the tasklist
     */
    @Override
    public synchronized void editTask(ReadOnlyTask target, Task task) throws TaskNotFoundException, DuplicateTaskException {
        taskList.editTask(target, task);
        indicateTaskListChanged();
    }
    
    /**
     * Marks a task in the tasklist as complete
     */
    @Override
    public synchronized void markTaskComplete(ReadOnlyTask target, Task task) throws TaskNotFoundException {
        taskList.markTaskComplete(target, task);
        indicateTaskListChanged();
    }
    
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    /**
     * Checks if the tasks in the tasklist if the task has expired
     */
    @Override
    public synchronized void checkExpiry(Date currentDate, String currentTime) {
        if(taskList.checkExpiry(currentDate, currentTime))
            indicateTaskListChanged();
    }
    
    /**
     * Checks if the reminders in the tasks in the tasklist had already activated
     */
    @Override
    public synchronized void checkReminders() {
        if(taskList.checkReminders())
            indicateTaskListChanged();
    }
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    /**
     * Filters the tasklist to show overdue tasks
     */
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredOverdueTaskList() {    
        updateFilteredOverdueTaskList();
        return new UnmodifiableObservableList<>(filteredOverdueTasks);
    }
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    /**
     * Updates the list according to list command parameters
     */
    @Override
    public void updateFilteredTaskList(String date, String preposition){
        if("".equals(preposition))
            updateFilteredTaskList(new PredicateExpression(new StartOnAndEndOnDateQualifier(date)));
        else if("overdue".equals(preposition))
            updateFilteredTaskList(new PredicateExpression(new OverdueTaskQualifier()));
        else
            updateFilteredTaskList(new PredicateExpression(new EndUntilDateQualifier(date)));
    }
        
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    /**
     * Updates the tasklist to show overdue tasks
     */
    @Override
    public void updateFilteredOverdueTaskList() {
        updateFilteredOverdueTaskList(new PredicateExpression(new OverdueTaskQualifier()));
    }

```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    /**
     * Qualifier to determine if a task is expired
     */
    private class OverdueTaskQualifier implements Qualifier {
        
        OverdueTaskQualifier() {
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            return (task.getIsExpired() && !task.getIsCompleted() &&
                   ("").equals(task.getStartDate().value) && ("").equals(task.getStartTime().value) &&
                   !("").equals(task.getEndDate()) && !("").equals(task.getEndDate())) | 
                   (task.getIsExpired() && !task.getIsCompleted() &&
                   ("").equals(task.getStartDate().value) && ("").equals(task.getStartTime().value) &&
                   !("").equals(task.getEndDate()) && ("").equals(task.getEndDate()));
        }
        
        @Override
        public String toString() {
            return "isExpired";
        }
    }
    
```
###### \java\seedu\inbx0\model\ModelManager.java
``` java
    /**
     * Qualifier to determine if a task starts or ends on a certain date
     */
    private class StartOnAndEndOnDateQualifier implements Qualifier {
        private String date;
        
        StartOnAndEndOnDateQualifier(String date) {
            this.date = date;
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            return (date.equals(task.getStartDate().value) | date.equals(task.getEndDate().value)) && !task.getIsCompleted();
        }
        
        @Override
        public String toString() {
            return "date= " + date;
        }
    }
    
    /*
     * Qualifier to determine if a task is due by a certain date
     */
    private class EndUntilDateQualifier implements Qualifier {
        private String date;
        
        EndUntilDateQualifier(String date) {
            this.date = date;
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            Date today = null;
           
            boolean taskIsAfterCurrentDate = false;
            boolean taskIsBeforeDueDate = false;
            boolean dueByDate = false;
            try {
                today = new Date("today");
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
            
            int dueByNumberDate = Integer.parseInt(date.replaceAll("\\D+",""));
            int dueByDay = dueByNumberDate / 1000000;
            int dueByMonth = (dueByNumberDate / 10000) % 100;
            int dueByYear = dueByNumberDate % 10000;
             
            if (task.getEndDate().getYear() > today.getYear() | 
               (task.getEndDate().getYear() == today.getYear() && task.getEndDate().getMonth() > today.getMonth()) |
               (task.getEndDate().getYear() == today.getYear() && task.getEndDate().getMonth() == today.getMonth() &&
               task.getEndDate().getDay() >= today.getDay()))       
                taskIsAfterCurrentDate = true;
            
            if ((dueByYear > task.getEndDate().getYear()) |
               (dueByYear == task.getEndDate().getYear() && dueByMonth > task.getEndDate().getMonth()) |
               (dueByYear == task.getEndDate().getYear() && dueByMonth == task.getEndDate().getMonth() &&
               dueByDay >= task.getEndDate().getDay()))
                taskIsBeforeDueDate = true;
            
            if (taskIsAfterCurrentDate && taskIsBeforeDueDate)
                dueByDate = true;
           
            return dueByDate && !task.getIsCompleted();
                   
        }
        
```
###### \java\seedu\inbx0\model\reminder\ReminderTask.java
``` java
/**
 * Represents a Reminder for the task 
 */
public class ReminderTask {
    
    private Toolkit toolkit;
    private Timer timer;
    private Date date;
    private Time time;
    private ReadOnlyTask task;
    private boolean isAlive;
    
    public ReminderTask(Date date, Time time, ReadOnlyTask task, boolean isAlive) {
        toolkit = Toolkit.getDefaultToolkit();
        this.date = date;
        this.time = time;
        this.task = task;
        this.isAlive = true;
        
        Date currentDate = null;
        try {
            currentDate = new Date("now");
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        
        if (currentDate.value.equals(date.value)) {
            if (!("").equals(time.getTime())) {
                setTimer(time);
            } else {
                timer = new Timer();
                timer.schedule(new ReminderMessage(), 1);
            }
        }
    }
    
    /**
     * Sets the timer according to the start time of the Reminder
     */
    private void setTimer(Time time) {
        int reminderTime = Integer.parseInt(time.getTime().replaceAll("\\D+",""));
        int reminderHour = reminderTime / 100;
        int reminderMin = reminderTime % 100;
        
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.HOUR_OF_DAY, reminderHour);
        calendar.set(Calendar.MINUTE, reminderMin);
        calendar.set(Calendar.SECOND, 0);
        
        java.util.Date timerRemind = calendar.getTime();
        timer = new Timer();
        timer.schedule(new ReminderMessage(), timerRemind);
    }
    
    /**
     * Copy constructor.
     * @throws IllegalValueException if not valid
     */
    public ReminderTask(final ReminderTask source) throws IllegalValueException {
        this(source.getStartDate(), source.getStartTime(),source.getReadableOnlyTask(), source.getIsAlive());
    }
    
    /**
     * Getter methods for ReminderTask
     */
    public Date getStartDate() {
        return date;
    }
    
    public Time getStartTime() {
        return time;
    }

    public ReadOnlyTask getReadableOnlyTask() {
        return task;
    }
    
    public boolean getIsAlive() {
        return isAlive;
    }
    
    /**
     * Setter method for ReminderTask
     */
    public void setReadableOnlyTask(ReadOnlyTask task) {
       this.task = task;
    }
    
    /**
     * Cancels the ReminderTask
     */
    public void cancel() {
        timer.cancel();
     }
    
    /**
     * Format state as text for viewing.
     */
    public final String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append("Reminder")
                .append(" Start Date: ")
                .append(getStartDate())
                .append(" Start Time: ")
                .append(getStartTime());
        return builder.toString();
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReminderTask // this is first to avoid NPE below 
                && this.date.value.equals(((ReminderTask) other).date.value) // state checks here onwards
                && this.time.value.equals(((ReminderTask) other).time.value)
                && this.isAlive == (((ReminderTask) other).isAlive)
                && this.task.getName().equals(((ReminderTask) other).task.getName())
                && this.task.getStartDate().equals(((ReminderTask) other).task.getStartDate())
                && this.task.getStartTime().equals(((ReminderTask) other).task.getStartTime())
                && this.task.getEndDate().equals(((ReminderTask) other).task.getEndDate())
                && this.task.getEndTime().equals(((ReminderTask) other).task.getEndTime()));
    }
    
    class ReminderMessage extends TimerTask {
        public void run() {
            toolkit.beep();           
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Platform.runLater(() -> {
            EventsCenter.getInstance().post(new ShowReminderRequestEvent(task));
            EventsCenter.getInstance().post(new TaskPanelSelectionChangedEvent(task));
            });
            isAlive = false;
            timer.cancel();            
        }
    }
}
```
###### \java\seedu\inbx0\model\reminder\UniqueReminderList.java
``` java
/**
 * A list of reminders that enforces no nulls.
 *
 * Supports minimal set of list operations for the app's features.
 *
 * @see ReminderTask#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueReminderList implements Iterable<ReminderTask> {
    
    private final ObservableList<ReminderTask> internalList = FXCollections.observableArrayList();
    
    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    @SuppressWarnings("serial")
    public static class DuplicateReminderException extends DuplicateDataException {
        protected DuplicateReminderException() {
            super("Operation would result in duplicate reminders");
        }
    }
    
    /**
     * Signals that an operation targeting a specified reminder in the list would fail because
     * there is no such matching reminder in the list.
     */
    @SuppressWarnings("serial")
    public static class ReminderNotFoundException extends Exception {}

    /**
     * Constructs empty ReminderList.
     */
    public UniqueReminderList() {}
    
    /**
     * java collections constructor, enforces no null or duplicate elements.
     */
    public UniqueReminderList(Collection<ReminderTask> reminders) throws DuplicateReminderException {
        CollectionUtil.assertNoNullElements(reminders);
        if (!CollectionUtil.elementsAreUnique(reminders)) {
            throw new DuplicateReminderException();
        }
        internalList.addAll(reminders);
    }
    /**
     * Varargs/array constructor, enforces no nulls or duplicates.
     */
    public UniqueReminderList(ReminderTask... reminders) throws DuplicateReminderException {
        assert !CollectionUtil.isAnyNull((Object[]) reminders);
        final List<ReminderTask> initialReminders = Arrays.asList(reminders);
        if (!CollectionUtil.elementsAreUnique(initialReminders)) {
            throw new DuplicateReminderException();
        }
        internalList.addAll(initialReminders);
    }
    
    /**
     * Copy constructor, insulates from changes in source.
     */
    public UniqueReminderList(UniqueReminderList source) {
        internalList.addAll(source.internalList); // insulate internal list from changes in argument
    }
    
    /**
     * java set constructor, enforces no nulls.
     */
    public UniqueReminderList(Set<ReminderTask> reminders) {
        CollectionUtil.assertNoNullElements(reminders);
        internalList.addAll(reminders);
    }
    
    /**
     * All reminders in this list as a Set. This set is mutable and change-insulated against the internal list.
     */
    public Set<ReminderTask> toSet() {
        return new HashSet<>(internalList);
    }
     
    /**
     * Adds a Reminder to the list.
     *
     * @throws DuplicateReminderException if the reminder to add is a duplicate of an existing reminder in the list.
     */
    public void add(ReminderTask toAdd) throws DuplicateReminderException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateReminderException();
        }
        internalList.add(toAdd);
    }
    
    
    /**
     * Adds every reminder from the argument list that does not yet exist in this list.
     */
    public void mergeFrom(UniqueReminderList reminders) {
        final Set<ReminderTask> alreadyInside = this.toSet();
        for (ReminderTask reminder : reminders) {
            if (!alreadyInside.contains(reminder)) {
                internalList.add(reminder);
            }
        }
    }
    
    /**
     * Returns true if the list contains an equivalent reminder as the given argument.
     */
    public boolean contains(ReminderTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }
    
    /**
     * Removes the equivalent Reminder from the list.
     *
     * @throws ReminderNotFoundException if no such reminder could be found in the list.
     */
    public boolean remove(ReminderTask toRemove) throws ReminderNotFoundException {
        assert toRemove != null;
        final boolean reminderFoundAndDeleted = internalList.remove(toRemove);
        if (!reminderFoundAndDeleted) {
            throw new ReminderNotFoundException();
        }
        return reminderFoundAndDeleted;
    }
    
    public ObservableList<ReminderTask> getInternalList() {
        return internalList;
    }
    
    @Override
    public Iterator<ReminderTask> iterator() {
        return internalList.iterator();
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueReminderList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueReminderList) other).internalList));
    }
    
    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

}
```
###### \java\seedu\inbx0\model\task\Importance.java
``` java
/**
 * Represents Importance of a Task in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidImportance(String)}
 */
public class Importance {
    
    public static final String MESSAGE_IMPORTANCE_CONSTRAINTS = "Importance has to be alphabetical format and has three levels (green, yellow, red) \n"
                                                            + "Example: G OR yellow OR r";;
    public static final String IMPORTANCE_VALIDATION_REGEX = "[a-zA-Z]+";
    public static final int NUM_OF_STRINGS_IN_ALLOWED_IMPORTANCE_NAMES = 12;
    public static final String [] ALLOWED_IMPORTANCE_NAMES = new String [] {
                                                              "g", "G", "green", "Green",
                                                              "y", "Y", "yellow", "Yellow",
                                                               "r", "R", "red", "Red"                                                            
                                                             };
    
    public final String value;
    public final int level;
    
    /**
     * Validates given importance.
     *
     * @throws IllegalValueException if given start importance string is invalid.
     */
    
    public Importance(String importance) throws IllegalValueException {
        assert importance != null;
        String trimmedImportance = importance.trim();
        if("".equals(trimmedImportance) | trimmedImportance.length() == 0 | trimmedImportance == null) {
            this.value = "";
            this.level = 0;
        }
        else {
            if (!isValidImportance(trimmedImportance)) {
                throw new IllegalValueException(MESSAGE_IMPORTANCE_CONSTRAINTS);
            }
            else {
                this.value = changeStringIntoProperColorName(trimmedImportance);
        
                if ("Green".equals(value))
                    level = 1;
                else if("Yellow".equals(value))
                    level = 2;
                else if ("Red".equals(value))
                    level = 3;
                else
                    level = 0;
                } 
        }
    }
    
    private String changeStringIntoProperColorName(String trimmedImportance) {
        String importance = trimmedImportance;
        if("g".equals(importance) | "G".equals(importance) | "green".equals(importance))
            importance = "Green";
        else if ("y".equals(importance) | "Y".equals(importance) | "yellow".equals(importance))
            importance = "Yellow";
        else if ("r".equals(importance) | "R".equals(importance) | "red".equals(importance))
            importance = "Red";
        return importance;
    }

    /**
     * Returns true if a given string is a valid task start time.
     */
    public static boolean isValidImportance(String test) {
        
        return (test.matches(IMPORTANCE_VALIDATION_REGEX) && Arrays.asList(ALLOWED_IMPORTANCE_NAMES).contains(test));
    }
    
    @Override
    public String toString() {
        return value;
    }
    
    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public String getLevel() {
        return value;
    }
    
    public int getNumberLevel() {
        return level;
    }
}
```
###### \java\seedu\inbx0\model\task\Time.java
``` java
/**
 * Represents Time of a Event Task in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidTime(String)}
 */
public class Time {

    public static final String MESSAGE_TIME_CONSTRAINTS = "Time can either be a numeric string, alphanumeric string, or alphabet string \n"
                                                        + "Example: HH:MM format OR 3a (3am) OR 3 hours later";
    public static final String TIME_VALIDATION_REGEX = "\\d+";
    
    public final String value;
    
    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given start time string is invalid.
     * !isValidTime(time) &&
     */
    public Time(String time) throws IllegalValueException {
        assert time != null;
       
        if ( "".equals(time) | time.length() == 0 | time == null) {
            this.value = "";
        }
        else {
                try{
                    SimpleDateFormat timeFormat = new SimpleDateFormat ("HH:mm");
                    List<java.util.Date> getTime = new Parser().parse(time).get(0).getDates();
                    String currentTime = getCurrentTime();
                    if(timeFormat.format(getTime.get(0)).equals(currentTime))
                        this.value = "";
                    else
                        this.value = timeFormat.format(getTime.get(0)); 
                } catch (IndexOutOfBoundsException e) {
                    throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
                }
        }
       
    }
    
    /**
     * Returns true if a given string is a valid task start time or task end time.
     */
    public static boolean isValidTime(String test) {
        boolean hourCheck = false;
        boolean minCheck = false;
        
        if(test.matches(TIME_VALIDATION_REGEX) && (test.length() == 4)) {
            if((Integer.parseInt(test) / 100) < 24) {
                hourCheck = true;
            }
            
            if((Integer.parseInt(test) % 100) < 60) {
                minCheck = true;
            }
        }       
        return (hourCheck && minCheck);
    }
    
    /**
     * Returns the current time as a string
     */
    public static String getCurrentTime() {
        SimpleDateFormat timeFormat = new SimpleDateFormat ("HH:mm");
        List<java.util.Date> current = new Parser().parse("now").get(0).getDates();
        return timeFormat.format(current.get(0));
    }
    
    @Override
    public String toString() {
        return value;
    }
    

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Time // instanceof handles nulls
                && this.value.equals(((Time) other).value)); // state check
    }
    
    @Override
    public int hashCode() {
        return value.hashCode();
    }
    
    /**
     * Getter method for Time
     */
    public String getTime() {
        return value;
    }
}
```
###### \java\seedu\inbx0\model\task\UniqueTaskList.java
``` java
    /**
     * Edits the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException if the task that was edited is a duplicate of an existing task in the list
     */    
    public boolean edit(ReadOnlyTask toEdit, Task toEditWith) throws TaskNotFoundException, DuplicateTaskException {
        assert toEdit != null;
        int editTaskIndex = internalList.indexOf(toEdit);
        if (editTaskIndex < 0) {
            throw new TaskNotFoundException();
        }
        
        if (contains(toEditWith) && (internalList.indexOf(toEditWith) != editTaskIndex |
              ((toEdit.getName() == toEditWith.getName()) && 
               (toEdit.getStartDate().equals(toEditWith.getStartDate())) &&
               (toEdit.getStartTime().equals(toEditWith.getStartTime())) &&
               (toEdit.getEndDate().equals(toEditWith.getEndDate())) &&
               (toEdit.getEndTime().equals(toEditWith.getEndTime())) &&                
               (toEdit.getLevel().equals(toEditWith.getLevel())) &&
               (toEdit.getTags().equals(toEditWith.getTags()))))) {         
                throw new DuplicateTaskException();
        }       
        
        boolean taskEdited = false;
        final Task taskFoundAndEdited = internalList.set(editTaskIndex, toEditWith);  
        
        if(taskFoundAndEdited != null) 
            taskEdited = true;
        
        return taskEdited;
    }
    
```
###### \java\seedu\inbx0\model\task\UniqueTaskList.java
``` java
    /**
     * Marks the equivalent task from the list as completed.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean markComplete(ReadOnlyTask toMarkComplete, Task completedTask) throws TaskNotFoundException {
        assert toMarkComplete != null;
        int markCompletedTaskIndex = internalList.indexOf(toMarkComplete);
        if (markCompletedTaskIndex < 0) {
            throw new TaskNotFoundException();
        }
        
        boolean taskMarkedCompleted = false;
        final Task taskFoundAndMarkedCompleted = internalList.set(markCompletedTaskIndex, completedTask);  
        
        if(taskFoundAndMarkedCompleted != null) 
            taskMarkedCompleted = true;
        
        return taskMarkedCompleted;
    }
    
```
###### \java\seedu\inbx0\model\task\UniqueTaskList.java
``` java
    /**
     * Checks expiry and sets the boolean isExpired accordingly for the tasks in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */    
    public boolean checkExpiry(Date currentDate, String currentTime) {
        if(internalList.isEmpty()) {
            return false;
        }
        
        boolean changed = false;
        for(Task t : internalList) { 
            if(t.getEndDate().value.length() != 0 && t.getEndTime().value.length() != 0) {        
                if ((t.getEndDate().getYear() < currentDate.getYear()) | 
                    ((t.getEndDate().getYear() == currentDate.getYear()) && (t.getEndDate().getMonth() < currentDate.getMonth())) | 
                    ((t.getEndDate().getYear() == currentDate.getYear()) && (t.getEndDate().getMonth() == currentDate.getMonth()) && (t.getEndDate().getDay() < currentDate.getDay())) |
                    (t.getEndDate().value.equals(currentDate.value) && (Integer.parseInt(t.getEndTime().value.replaceAll("\\D+","")) <= Integer.parseInt(currentTime.replaceAll("\\D+",""))))) {          
                    if(!t.getIsExpired()) {
                        t.setExpired(true);
                        changed = true;
                    }
                }
            }
            else if (t.getEndDate().value.length() != 0 && t.getEndTime().value.length() == 0) {
                    if ((t.getEndDate().getYear() < currentDate.getYear()) |
                       ((t.getEndDate().getYear() == currentDate.getYear()) && (t.getEndDate().getMonth() < currentDate.getMonth())) |
                       ((t.getEndDate().getYear() == currentDate.getYear()) && (t.getEndDate().getMonth() == currentDate.getMonth())
                       && (t.getEndDate().getDay() < currentDate.getDay()))) {
                        if(!t.getIsExpired()) {
                            t.setExpired(true);
                            changed = true;
                        }             
                    }
                }  
            }  
        return changed;
    }
    
```
###### \java\seedu\inbx0\model\task\UniqueTaskList.java
``` java
    /**
     * Checks reminders and remove them if they have been activated.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean checkReminders() {
        if(internalList.isEmpty()) {
            return false;
        }
        
        boolean changed = false;
        for(Task t : internalList) { 
            UniqueReminderList reminders = t.getReminders();
            Iterator<ReminderTask> check = reminders.iterator();
            while(check.hasNext()) {
                if(!check.next().getIsAlive()) {
                    check.remove();
                    changed = true;
                }
            }
          t.setReminders(reminders);
        }
        return changed;
    }
    
```
###### \java\seedu\inbx0\ui\MainWindow.java
``` java
    /**
     * Loads the Overdue Task Window.
     */
    @FXML
    public void handleOverdueTasks() {
        OverdueTaskWindow overdueTaskWindow = OverdueTaskWindow.load(primaryStage, logic);
        overdueTaskWindow.show();
    }
```
###### \java\seedu\inbx0\ui\MainWindow.java
``` java
    /**
     * Loads the Reminder Window.
     */
    public void handleReminder(ReadOnlyTask task) {
        ReminderWindow reminderWindow = ReminderWindow.load(primaryStage, task);
        reminderWindow.show();
    }
    
```
###### \java\seedu\inbx0\ui\OverdueTaskWindow.java
``` java
public class OverdueTaskWindow extends UiPart {

    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String ICON = "/images/help_icon.png";
    private static final String FXML = "OverdueTaskWindow.fxml";
    private static final String TITLE = "Overdue Tasks";
    public static final int MIN_HEIGHT = 600;
    public static final int MIN_WIDTH = 450;

    private VBox mainPane;
    private Scene scene;
    private Stage dialogStage;
    private TaskListPanel taskListPanel;
    
    @FXML
    private AnchorPane taskListPanelPlaceholder;

    public static OverdueTaskWindow load(Stage primaryStage, Logic logic) {
        logger.fine("Showing overdue tasks.");
        OverdueTaskWindow overdueTaskWindow = UiPartLoader.loadUiPart(primaryStage, new OverdueTaskWindow());
        overdueTaskWindow.configure(logic);
        return overdueTaskWindow;
    }

    @Override
    public void setNode(Node node) {
        mainPane = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    private void configure(Logic logic){
        Stage dialogStage = new Stage();
        dialogStage.initModality(Modality.APPLICATION_MODAL);
        this.dialogStage = dialogStage;
        
        setTitle(TITLE);
        setIcon(dialogStage, ICON);
        setWindowMinSize();
        dialogStage.setResizable(false);
        scene = new Scene(mainPane);
        dialogStage.setScene(scene);
        taskListPanel = TaskListPanel.load(dialogStage, getTaskListPlaceholder(), logic.getFilteredOverdueTaskList());
        
    }
    

    public void show() {
        dialogStage.showAndWait();
    }
    
    public AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }
    
    public TaskListPanel getTaskListPanel() {
        return this.taskListPanel;
    }
    
    private void setTitle(String title) {
        dialogStage.setTitle(title);
    }
    
    private void setWindowMinSize() {
        dialogStage.setMinHeight(MIN_HEIGHT);
        dialogStage.setMinWidth(MIN_WIDTH);
    }
}
```
###### \java\seedu\inbx0\ui\ReminderListCard.java
``` java
public class ReminderListCard extends UiPart{

    private static final String FXML = "ReminderListCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private GridPane gridPane;
    
    @FXML
    private ColumnConstraints firstColumn;

    @FXML
    private ColumnConstraints secondColumn;

    @FXML
    private ColumnConstraints thirdColumn;

    @FXML
    private Label id;
    @FXML
    private Label startDate;
    @FXML
    private Label startTime;

    private ReminderTask reminder;
    private int displayedIndex;

    public static ReminderListCard load(ReminderTask reminder, int displayedIndex){
        ReminderListCard card = new ReminderListCard();
        card.reminder = reminder;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        id.setText(displayedIndex + ". ");
        startDate.setText(reminder.getStartDate().getTotalDate());
        startTime.setText(reminder.getStartTime().getTime()); 
        setGridPaneRatio();
    }
    
    private void setGridPaneRatio() {
    	firstColumn.setMaxWidth(200);
    	secondColumn.setMaxWidth(200);
    	thirdColumn.setMaxWidth(200);
    	firstColumn.setMinWidth(200);
    	secondColumn.setMinWidth(200);
    	thirdColumn.setMinWidth(200);
	}

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}

```
###### \java\seedu\inbx0\ui\ReminderWindow.java
``` java
public class ReminderWindow extends UiPart {
    
    private static final Logger logger = LogsCenter.getLogger(ReminderWindow.class);
    private static final String FXML = "ReminderWindow.fxml";
    private static final String ICON = "/images/help_icon.png";
    private static final String TITLE = "Reminder!";
    
    @FXML
    private Label name;
    @FXML
    private Label startDate;
    @FXML
    private Label startTime;
    @FXML
    private Label endDate;
    @FXML
    private Label endTime;
    @FXML
    private Button OkayButton;
    
    private ReadOnlyTask task;
    private Stage reminderStage;
    private VBox mainPane;
    
    public static ReminderWindow load(Stage primaryStage, ReadOnlyTask task){
        logger.fine("Showing reminders");
        ReminderWindow reminderWindow = UiPartLoader.loadUiPart(primaryStage, new ReminderWindow());
        reminderWindow.configure(task);
        return reminderWindow;
    }
    
    public void displayInfo() {
        name.setText(task.getName().getName());
        startDate.setText(task.getStartDate().getTotalDate());
        startTime.setText(task.getStartTime().getTime());
        endDate.setText(task.getEndDate().getTotalDate());
        endTime.setText(task.getEndTime().getTime());
    }
    
    private void configure(ReadOnlyTask task){
        this.task = task;        
        Scene scene = new Scene(mainPane);
        //Null passed as the parent stage to make it non-modal.
        reminderStage = createDialogStage(TITLE, null, scene);
        setIcon(reminderStage, ICON);
        displayInfo();
    }
    
    @Override
    public void setNode(Node node) {
        mainPane = (VBox) node;
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    public void show() {
        reminderStage.showAndWait();
    }
    
    @FXML
    public void handleCloseReminder() {
        reminderStage.close();
    }
    
    @FXML
    public void keyPressed(KeyEvent evt) {
        if(evt.getCode().equals(KeyCode.ENTER)) {
            handleCloseReminder();
        }
        
    }
}
```
###### \java\seedu\inbx0\ui\UiManager.java
``` java
    /**
     * Handles ShowReminderEvent and displays the reminder window
     */
    @Subscribe
    private void handleShowReminderEvent(ShowReminderRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleReminder(event.task);
    }
    
```
###### \resources\view\OverdueTaskWindow.fxml
``` fxml
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.control.TextField?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.inbx0.ui.OverdueTaskWindow">
	<stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
   		<VBox fx:id="taskList" minWidth="340" prefWidth="340" minHeight="555">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0"/>
                </padding>
               <children>
                  <AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS"/>
               </children>
         </VBox>
    </children>
 </VBox>       
```
