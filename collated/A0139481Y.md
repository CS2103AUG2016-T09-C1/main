# A0139481Y
###### \docs\UserGuide.md
``` md
#### <a id="tag"></a>7. Modifying the taglist: `addtag` / `deltag`
1) Adding more tags
Format: `addtag INDEX t=TAGS [t=MORE_TAGS]`

If you wish to add additional tags to any existing tasks, you can do it by typing the following: `addtag INDEX t=TAGS [t=MORE_TAGS]` <br>

Note that adding tags and editing tags are different commands. Edit tags will remove all tags and add in the editted tag. This addtag command will just append the new tag behind any existing tag names.

Examples: 
* `list today`<br>
  `addtag 2 t=tonight`<br>
  Adds the "tonight" tag to the 2nd task in the list.

2) Deleting a particular tag
Format: `deltag INDEX t=TAGS [t=MORE_TAGS]`

Is you wish to remove specific tags from the list of tags, simply type in `deltag INDEX t=TAGS [t=MORE_TAGS]` to remove it/them.

```
###### \docs\UserGuide.md
``` md
#### <a id="undo"></a>10. Undo previous action: `undo`
Format: `undo`

Undos the previous action done in the task manager if you've made a mistake. <br>

```
###### \docs\UserGuide.md
``` md
## **Command Summary**

Command | Format  
-------- | :-------- 
[Help](#help) | `help`
[Add](#add) | `add TASK [i=IMPORTANCE] [t=TAGS]...`
&nbsp; | `add TASK e=[END_DATE] [END_TIME] [i=IMPORTANCE] [t=TAGS]...`
&nbsp; | `add TASK s=[START_DATE] [START_TIME][i=IMPORTANCE] [t=TAGS]...`
&nbsp; | `add TASK s=[START_DATE] [START_TIME] e=[END_DATE] [END_TIME] [i=IMPORTANCE] [t=TAGS]...`
[List](#list) | `list [DATE]`
&nbsp; | `list due DATE`
&nbsp; | `list overdue`
[Find](#find) | Normal search: `find KEYWORD [MORE_KEYWORDS]...`
&nbsp; | Logic operation search: `find KEYWORD [LOGIC_OPERATOR] [MORE_KEYWORDS] [MORE_LOGIC_OPERATOR]...`
[Sort](#sort) | `sort [n|s|e|i] [ASC\DESC]`
[Edit](#edit) | `edit INDEX [n=NAME] [s=START_DATE] [st=START_TIME] [e=END_DATE] [et=END_TIME] [i=IMPORTANCE]`
[Addtag / Deltag](#tag) | `tag INDEX t=TAGS [t=MORE_TAGS]`
[Delete](#del) | `del INDEX`
[Select](#sel) | `sel INDEX`
[Undo](#undo) | `undo`
[Clear](#clr) | `clr`
[Done](#done) | `done INDEX [INDEX]...`
&nbsp; | `done FIRST_INDEX to LAST_INDEX`
[Exit](#exit) | `exit`

## **FAQ**

**Q**: How do I transfer my data to another Computer?<br>
**A**: Install the app in the other computer and overwrite the empty data file it creates with 
       the file that contains the data of your previous Address Book folder.

**Q**: How do check if I have the correct Java Version?<br>
**A**: <br>
On Windows:
 1. Click Start on the task bar.
 2. Select Control Panel (or Settings > Control Panel) from the Start menu. The Control Panel is displayed.
 3. Select Java. The Java Control Panel dialog box is displayed .
 4. NOTE: if the Control Panel is in Category mode and you cannot see the Java option, switch the Control Panel to Classic View.
 5. Click the Java tab.
 6. In the Java Application Runtime Setting box, click View. The JNLP Runtime Settings dialog box is displayed.

On Macs:
 1. Open Terminal (Navigate to **Applications** > **Utilities** > **Terminal**))
 2. Type `java -version`.
 3. The Java version and related information displays. For example:

>Users-MacBook-Pro:~ user$ java -version <br>
java version "1.6.0\_51"Java(TM) SE Runtime Environment (build 1.6.0_51-b11-457-11M4509) <br>
Java HotSpot(TM) 64-Bit Server VM (build 20.51-b01-457, mixed mode)

On Linux:
 1. Open Terminal (this can be different depending on which version of Linux you are running. For example, in Ubuntu, navigate to **Applications** > **Accessories** > **Terminal**). In Red Hat, right-click the desktop, and select Open in Terminal from the pull-down menu.
 2. Type `java -version`.
 3. The Java version and related information displays. For example:

>user@user-desktop:~$ java -version <br>
java version "1.7.0\_15"Java(TM) SE Runtime Environment (build 1.7.0_05-b06) <br>
Java HotSpot(TM) Client VM (build 23.1-b03, mixed mode)
```
###### \src\main\java\seedu\inbx0\logic\commands\AddCommand.java
``` java
    @Override
    public boolean canUndo() {  
        return true;
    }
}
```
###### \src\main\java\seedu\inbx0\logic\commands\AddTagCommand.java
``` java
public class AddTagCommand extends Command {
	
	public static final String COMMAND_WORD = "addtag";
	
	public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Adds 1 or more tags to an existing task.\n"
            + "Parameters: INDEX (must be a positive integer) [t=TAG]... (must have at least one tag) \n"
            + "Example: " + COMMAND_WORD + " 1 " + "t=cute \n";
	
	public static final String MESSAGE_SUCCESS = "Tag successfully added!";
	public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the tasklist";
	public static final String TAGS_INVALID_ARGUMENTS = "You must input at least 1 tag!";
	
	public final int targetIndex;
    public UniqueTagList tags;
	
```
###### \src\main\java\seedu\inbx0\logic\commands\AddTagCommand.java
``` java
    public AddTagCommand(int targetIndex,  Set<String> tags) throws IllegalValueException {
    	
    	this.targetIndex = targetIndex;
        
        final Set<Tag> tagSet = new HashSet<>();
       
        for (String tagName : tags) {
        	tagSet.add(new Tag(tagName));
        }
            
        UniqueTagList addedTags = null;
            
        if(!tagSet.isEmpty()) {
            addedTags = new UniqueTagList(tagSet);
        }
          
        this.tags = addedTags;
    }
    
    private UniqueTagList obtainUniqueTagList(ReadOnlyTask taskToEdit) {
        
        UniqueTagList original = taskToEdit.getTags();
              
        return original;
    }
    
    private Task createToEditWithTask(ReadOnlyTask taskToEdit, UniqueTagList tags) throws IllegalValueException{
    	
    	
    	Task toEditWith = new Task (
                new Name(taskToEdit.getName().getName()),
                new Date(taskToEdit.getStartDate().getDate()),
                new Time(taskToEdit.getStartTime().getTime()),
                new Date(taskToEdit.getEndDate().getDate()),
                new Time(taskToEdit.getEndTime().getTime()),
                new Importance(taskToEdit.getLevel().getLevel()),
                tags,
                new UniqueReminderList(taskToEdit.getReminders())
                );
        return toEditWith;
    }
    
	@Override
    public CommandResult execute() {
		
		UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);
        
        UniqueTagList originalTags = obtainUniqueTagList(taskToEdit);
        
        originalTags.mergeFrom(tags);
        
        Task toEditWith = null;
        
        try {
            toEditWith = createToEditWithTask(taskToEdit, originalTags);
        } catch (IllegalValueException e1) {
            return new CommandResult(TAGS_INVALID_ARGUMENTS);
        }
        
        try {
            model.editTask(taskToEdit, toEditWith);
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        } catch (UniqueTaskList.DuplicateTaskException e ) {    
            return new CommandResult(MESSAGE_DUPLICATE_TASK);            
        }
        
        return new CommandResult(MESSAGE_SUCCESS);
    }

    @Override
    public boolean canUndo() {
        return true;
    }
}
```
###### \src\main\java\seedu\inbx0\logic\commands\Command.java
``` java
    public abstract boolean canUndo();

    /**
     * Raises an event to indicate an attempt to execute an incorrect command
     */
    protected void indicateAttemptToExecuteIncorrectCommand() {
        EventsCenter.getInstance().post(new IncorrectCommandAttemptedEvent(this));
    }
    
    /**
     * Raises an event to indicate show normal task list
     */
    protected void indicateShowNormalTaskListEventCommand() {
        EventsCenter.getInstance().post(new ShowNormalTaskListEvent());
    }
}
```
###### \src\main\java\seedu\inbx0\logic\commands\DelTagCommand.java
``` java
public class DelTagCommand extends Command {
    
    public static final String COMMAND_WORD = "deltag";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes 1 or more tags from an existing task.\n"
            + "Parameters: INDEX (must be a positive integer) [t=TAG]... (must have at least one tag) \n"
            + "Example: " + COMMAND_WORD + " 1 " + "t=cute \n";
    
    public static final String MESSAGE_SUCCESS = "Tag successfully deleted!";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the tasklist";
    public static final String TAGS_INVALID_ARGUMENTS = "You must input at least 1 tag!";
    
    public final int targetIndex;
    public UniqueTagList tags;
    
```
###### \src\main\java\seedu\inbx0\logic\commands\DelTagCommand.java
``` java
    public DelTagCommand(int targetIndex,  Set<String> tags) throws IllegalValueException {
        
        this.targetIndex = targetIndex;
        
        final Set<Tag> tagSet = new HashSet<>();
       
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
            
        UniqueTagList addedTags = null;
            
        if(!tagSet.isEmpty()) {
            addedTags = new UniqueTagList(tagSet);
        }
          
        this.tags = addedTags;
    }
    
    private UniqueTagList obtainUniqueTagList(ReadOnlyTask taskToEdit) {
        
        UniqueTagList original = taskToEdit.getTags();
              
        return original;
    }
    
    private Task createToEditWithTask(ReadOnlyTask taskToEdit, UniqueTagList tags) throws IllegalValueException{
        
        
        Task toEditWith = new Task (
                new Name(taskToEdit.getName().getName()),
                new Date(taskToEdit.getStartDate().getDate()),
                new Time(taskToEdit.getStartTime().getTime()),
                new Date(taskToEdit.getEndDate().getDate()),
                new Time(taskToEdit.getEndTime().getTime()),
                new Importance(taskToEdit.getLevel().getLevel()),
                tags,
                new UniqueReminderList(taskToEdit.getReminders())
                );
        return toEditWith;
    }
    
    @Override
    public CommandResult execute() {
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);
        
        UniqueTagList originalTags = obtainUniqueTagList(taskToEdit);
        
        originalTags.removeFrom(tags);
        
        Task toEditWith = null;
        
        try {
            toEditWith = createToEditWithTask(taskToEdit, originalTags);
        } catch (IllegalValueException e1) {
            return new CommandResult(TAGS_INVALID_ARGUMENTS);
        }
        
        try {
            model.editTask(taskToEdit, toEditWith);
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        } catch (UniqueTaskList.DuplicateTaskException e ) {    
            return new CommandResult(MESSAGE_DUPLICATE_TASK);            
        }
        
        return new CommandResult(MESSAGE_SUCCESS);
    }

    @Override
    public boolean canUndo() {
        return true;
    }
}
```
###### \src\main\java\seedu\inbx0\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends Command {
    
    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undo the last command(s)\n"
            + "Parameters: [STEPS_BACK]\n"
            + "Example: " + COMMAND_WORD + " 2";

    public static final String MESSAGE_UNDO_TASK_SUCCESS = "Last Command undone successfully.";
    public static final String MESSAGE_NOTHING_TO_UNDO = "There is no past command to undo.";
    
    private final int stepsBack;
    
    public UndoCommand() {
        stepsBack = 1;
    }
    
    public UndoCommand(int stepsBack) {
        this.stepsBack = stepsBack;
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        
        int commandsUndone = model.undoTaskListHistory(stepsBack);
        
        if (commandsUndone == 0){
            return new CommandResult(MESSAGE_NOTHING_TO_UNDO);
        }
        
        return new CommandResult(MESSAGE_UNDO_TASK_SUCCESS);
    }
    
    @Override
    public boolean canUndo() {
        return false;
    }
}
```
###### \src\main\java\seedu\inbx0\logic\parser\Parser.java
``` java
    private Command prepareAddTag(final String args) {
        final Matcher matcher = ADD_TAGS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddTagCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = parseIndex(matcher.group("targetIndex"));
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddTagCommand.MESSAGE_USAGE));
        }
        try {
            return new AddTagCommand(index.get(), getTagsFromArgs(matcher.group("tagArguments")));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the delete tag command.
     *
     * @param args full command args string
     * @return the prepared command
     */
```
###### \src\main\java\seedu\inbx0\logic\parser\Parser.java
``` java
    private Command prepareDelTag(final String args) {
        final Matcher matcher = ADD_TAGS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DelTagCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = parseIndex(matcher.group("targetIndex"));
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DelTagCommand.MESSAGE_USAGE));
        }
        try {
            return new DelTagCommand(index.get(), getTagsFromArgs(matcher.group("tagArguments")));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the Mark Complete task command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
```
###### \src\main\java\seedu\inbx0\logic\parser\Parser.java
``` java
    private Command prepareUndo(String args) {
        if(args.trim().length() == 0) {
            return new UndoCommand();
        }
        
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }

        return new UndoCommand(index.get());
    }

    /**
     * Parses arguments in the context of the delete task command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
```
###### \src\main\java\seedu\inbx0\model\history\HistoryList.java
``` java
public class HistoryList<T extends HistoryState<T>> {
    
    private static final int MAX_NUM_HISTORY_STORED = 10;
    private final int maxNumOfHistoryCommands;
    private final LinkedList<T> historyList;
    
    /**
     * Default constructor
     */
    public HistoryList() {
        this(MAX_NUM_HISTORY_STORED);
    }
    
    /**
     * Creates HistoryStack which can store up to
     * a number of history item states.
     * 
     * @param maxNumOfStates max number of history states
     */
    public HistoryList(int maxNumOfHistoryCommands) {
        assert maxNumOfHistoryCommands > 0;
        this.maxNumOfHistoryCommands = maxNumOfHistoryCommands;
        historyList = new LinkedList<T>();
    }
    
    /**
     * Push a history task to be saved as a history state.
     * 
     * @param item Object to be saved
     */
    public void pushState(T item) {
        assert item != null;
        
        if (historyList.size() >= maxNumOfHistoryCommands) {
            historyList.removeFirst();
        }
        historyList.addLast(item.copyCurrentState());
    }
    
    /**
     * Pops and returns the latest history state stored.
     * 
     * @return The HistoryState object
     * @throws EmptyHistoryException if the history queue is empty
     */
    public T popState() throws EmptyHistoryException {
        if (historyList.size() <= 0)
            throw new EmptyHistoryException();
        
        return historyList.removeLast();
    }
    
    @SuppressWarnings("serial")
    public static class EmptyHistoryException extends Exception {
        protected EmptyHistoryException() {
            super("There is noting to undo.");
        }
    }
}
```
###### \src\main\java\seedu\inbx0\model\history\HistoryState.java
``` java
public interface HistoryState<T> {
    T copyCurrentState();
}
```
###### \src\main\java\seedu\inbx0\model\Model.java
``` java
    //** Saves the current state of the TaskList into a temporary history list **/
    void saveTaskListHistory();
    
    /**
     * @return number of history states undone
     */
    int undoTaskListHistory(int stepsBack);
```
###### \src\main\java\seedu\inbx0\model\ModelManager.java
``` java
    @Override
    public void saveTaskListHistory() {
        taskListHistory.pushState(taskList);
    }
    
    @Override
    public int undoTaskListHistory(int stepsBack) {
        assert stepsBack > 0;
        
        int numUndone = 0;
        TaskList historyList = null;
        try {
            for (int i = 0; i < stepsBack; i++) {
                historyList = taskListHistory.popState();
                numUndone++;
            }
        } catch (EmptyHistoryException e) {
            logger.fine(e.getMessage());
        }
        
        if (historyList != null) {
            resetData(historyList);
        }
        
        return numUndone;
    }
```
###### \src\main\java\seedu\inbx0\model\tag\UniqueTagList.java
``` java
    public void removeFrom(UniqueTagList tags) {
        final Set<Tag> alreadyInside = this.toSet();
        for (Tag tag : tags) {
            if (alreadyInside.contains(tag)) {
                internalList.remove(tag);
            }
        }
    }

    /**
     * Returns true if the list contains an equivalent Tag as the given argument.
     */
    public boolean contains(Tag toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a Tag to the list.
     *
     * @throws DuplicateTagException if the Tag to add is a duplicate of an existing Tag in the list.
     */
    public void add(Tag toAdd) throws DuplicateTagException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTagException();
        }
        internalList.add(toAdd);
    }

    @Override
    public Iterator<Tag> iterator() {
        return internalList.iterator();
    }

    public ObservableList<Tag> getInternalList() {
        return internalList;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTagList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueTagList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### \src\main\java\seedu\inbx0\model\TaskList.java
``` java
    @Override
    public TaskList copyCurrentState() {
        return new TaskList(this);
    }
```
###### \src\test\java\guitests\AddCommandTest.java
``` java
        //add another task
        taskToAdd = td.noImportance;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        //add floating task
        taskToAdd = td.floating;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        //add floating task without importance
        taskToAdd = td.floatingNoImportance;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        //add deadline task
        taskToAdd = td.deadline;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        //add deadline task with no importance
        taskToAdd = td.deadlineNoImportance;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
```
###### \src\test\java\guitests\DoneCommandTest.java
``` java
public class DoneCommandTest extends TaskListGuiTest {
    
    @Test
    public void done() throws IllegalArgumentException, IllegalValueException {
        
        //marks the first task in the list as done
        TestTask[] currentList = td.getTypicalTasks();
        int targetIndex = 1;
        assertMarkAsDoneSuccess(targetIndex, currentList);
        
        //marks a task that is already marked as done
        commandBox.runCommand("done " + 1);
        assertResultMessage(MarkCompleteCommand.MESSAGE_TASK_ALREADY_COMPLETED);
        
        //invalid index for marking
        commandBox.runCommand("done " + 13);
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        
        //invalid command
        commandBox.runCommand("donee 1");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }
    
    /**
     * 
     * Runs the Mark Complete command to mark the task at the specified index as done and confirms the result is correct 
     * @param targetIndexOneIndexed e.g. to mark the first task in the list as done, 1 should be given as the target index.
     * @param category the category in which to mark as done from.
     * @param currentList A copy of the current list of tasks (before being marked as done).     
     */
    private void assertMarkAsDoneSuccess(int targetIndex, final TestTask[] currentList) throws IllegalArgumentException, IllegalValueException {
        TestTask taskToMark = currentList[targetIndex-1]; //-1 because array uses zero indexing
        
        taskToMark.markAsDone();
        commandBox.runCommand("done " + targetIndex);
        
        //confirm the list now contains the original list + the task marked as done
        assertTrue(taskListPanel.isListMatching(currentList));
        
        // find task card of marked task
        TaskCardHandle markedCard = taskListPanel.navigateToTask(taskToMark.getName().fullName);
        // confirm its the correct task
        assertMatching(taskToMark, markedCard);
        // confirm the task is marked
        assertDone(markedCard);
        
        //confirm the result message is correct
        assertResultMessage(String.format(Messages.MESSAGE_TASKS_COMPLETED_OVERVIEW, 1));
    }
}
```
###### \src\test\java\guitests\EditCommandTest.java
``` java
    @Test
    public void edit() throws IllegalArgumentException, IllegalValueException{
        TestTask[] currentList = td.getTypicalTasks();
        int targetIndex = 1;
        
        //edit the 1st task in the list
        assertEditSuccess(targetIndex, td.hoon, currentList);
        currentList = TestUtil.replaceTaskFromList(currentList, td.hoon, targetIndex - 1);
        
        //add a tag
        Tag tagToAdd = new Tag("urgent");
        commandBox.runCommand("addtag " + targetIndex + " t=urgent");
        ReadOnlyTask newTask = taskListPanel.getTask(targetIndex - 1);
        assertTrue(newTask.getTags().contains(tagToAdd));
        
         //invalid index for adding tag
        commandBox.runCommand("deltag " + 13 + " t=urgent");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        
        //delete a tag
        Tag tagToDelete = new Tag("urgent");
        commandBox.runCommand("deltag " + targetIndex + " t=urgent");
        ReadOnlyTask newTask2 = taskListPanel.getTask(targetIndex - 1);
        assertFalse(newTask2.getTags().contains(tagToDelete));
        
        //invalid index for delete tag
        commandBox.runCommand("deltag " + 13 + " t=urgent");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        // invalid command
        commandBox.runCommand("edit Kitty");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        
        // invalid command, no parameters given
        commandBox.runCommand("edit");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        
        // invalid index
        commandBox.runCommand(td.ida.getAddCommand().replace("add", "edit " + (currentList.length+1) + " n="));
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }
    
    private void assertEditSuccess(int targetIndex, TestTask editedTask, TestTask... currentList) throws IllegalArgumentException, IllegalValueException {
        commandBox.runCommand(editedTask.getAddCommand().replace("add", "edit " + targetIndex + " n="));

        //confirm the new card contains the right data
        TaskCardHandle editedCard = taskListPanel.navigateToTask(targetIndex-1);
        assertMatching(editedTask, editedCard);

        //confirm the list now contains all previous tasks with updated task
        currentList[targetIndex - 1] = editedTask;
        assertTrue(taskListPanel.isListMatching(currentList));
      
        assertResultMessage(String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS, editedTask));
    }
}
```
###### \src\test\java\guitests\guihandles\TaskListPanelHandle.java
``` java
    public TaskCardHandle navigateToTask(int index) throws IllegalValueException {
           guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getTaskCardHandle(index);
    }
```
###### \src\test\java\guitests\TaskListGuiTest.java
``` java
    /**
     * Asserts the task shown is marked as done by verifying that it has a tick ASCII.
     */
    public void assertDone(TaskCardHandle card) {
        assertEquals("\u2713", card.getStyleName());
    }
```
###### \src\test\java\seedu\inbx0\testutil\TestTask.java
``` java
    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + this.getName().fullName + " ");
        if (this.getStartDate() != null)
            sb.append("s=" + this.getStartDate().value + " ");
        if (this.getStartTime() != null)
            sb.append("st=" + this.getStartTime().value + " ");
        if (this.getEndDate() != null)
            sb.append("e=" + this.getEndDate().value + " ");
        if (this.getEndTime() != null)
            sb.append("et=" + this.getEndTime().value + " ");
        if (this.getLevel() != null)
            sb.append("i=" + this.getLevel().value + " ");
        this.getTags().getInternalList().stream().forEach(s -> sb.append("t=" + s.tagName + " "));
        return sb.toString();
    }
    
    public void markAsDone() {
        isCompleted = true;
    }
}
```
###### \src\test\java\seedu\inbx0\testutil\TypicalTestTasks.java
``` java
            noImportance = new TaskBuilder().withName("No importance").withStartDate("next wed").withStartTime("1000").withEndDate("next thurs").withEndTime("12pm").withTags("tagged").build();
            floatingNoImportance = new TaskBuilder().withName("Float no importance").withTags("tag123").build();
            floating = new TaskBuilder().withName("Floating Task").withImportance("G").withTags("tag1515").build();
            deadline = new TaskBuilder().withName("Deadline").withEndDate("next week").withEndTime("12pm").withImportance("Red").withTags("tagged").build();
            deadlineNoImportance = new TaskBuilder().withName("Deadline no importance").withEndDate("next week").withEndTime("12pm").withTags("tagged").build();
```
